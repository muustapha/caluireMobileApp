"use strict";
// noinspection ExceptionCaughtLocallyJS
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.summary = exports.runTask = exports.shellTask = void 0;
const child_process_1 = require("child_process");
const path_1 = __importDefault(require("path"));
const picocolors_1 = __importDefault(require("picocolors"));
const constants_1 = require("../constants");
const prompter_1 = require("../prompter");
const getErrMessage_1 = require("../utils/getErrMessage");
const getProjectPath_1 = require("../utils/getProjectPath");
const parseArgs_1 = require("../utils/parseArgs");
const satisfies_1 = require("../utils/satisfies");
const setState_1 = require("../utils/setState");
const variables_1 = require("../variables");
async function shellTask(args) {
    const { task, packageName } = args;
    for (const action of task.actions) {
        if (action.when && !(0, satisfies_1.satisfies)(variables_1.variables.getStore(), action.when)) {
            (0, setState_1.setState)(action.name, {
                state: 'skipped',
                reason: 'when',
                error: false,
            });
            continue;
        }
        (0, setState_1.setState)(action.name, {
            state: 'progress',
            error: false,
        });
        try {
            let command, args, cwd;
            if (action.args) {
                command = action.command;
                args = action.args;
            }
            else {
                const cmdWithArgs = (0, parseArgs_1.parseArgs)(action.command);
                command = cmdWithArgs[0];
                args = cmdWithArgs.slice(1);
            }
            if (action.cwd) {
                const cwdPath = path_1.default.join((0, getProjectPath_1.getProjectPath)(), action.cwd);
                // security check
                if (!cwdPath.startsWith((0, getProjectPath_1.getProjectPath)())) {
                    throw new Error('invalid cwd path');
                }
                cwd = cwdPath;
            }
            if (packageName !== constants_1.Constants.UPGRADE_CONFIG_FILE_NAME) {
                const isAllowed = await (0, prompter_1.confirm)(`requesting permission to run ${picocolors_1.default.yellow(command + ' ' + args.join(' '))}`, {
                    positive: 'allow',
                    negative: 'skip',
                });
                if (!isAllowed) {
                    (0, setState_1.setState)(action.name, {
                        state: 'skipped',
                        reason: 'user denied',
                        error: false,
                    });
                    (0, prompter_1.logMessageGray)(`skipped running ${picocolors_1.default.yellow(command + ' ' + args.join(' '))}`);
                    continue;
                }
            }
            let output = '';
            (0, prompter_1.startSpinner)(`running ${picocolors_1.default.yellow(command + ' ' + args.join(' '))}`);
            let exitCode = undefined;
            try {
                exitCode = await new Promise((resolve, reject) => {
                    try {
                        const child = (0, child_process_1.spawn)(command, args, { cwd });
                        child.stdout.on('data', (chunk) => {
                            output += chunk.toString('utf8');
                        });
                        child.stderr.on('data', (chunk) => {
                            output += chunk.toString('utf8');
                        });
                        // child.stdout.pipe(process.stdout);
                        // child.stderr.pipe(process.stderr);
                        child.on('close', code => {
                            resolve(code);
                        });
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            }
            finally {
                if (action.name)
                    variables_1.variables.set(`${action.name}.output`, output);
                if (exitCode == null) {
                    // throwing error
                    (0, prompter_1.stopSpinner)(`run failed using ${picocolors_1.default.yellow(command + ' ' + args.join(' '))}`);
                }
            }
            if (exitCode != 0) {
                (0, prompter_1.stopSpinner)(`run failed using ${picocolors_1.default.yellow(command + ' ' + args.join(' '))}`);
                throw new Error(`process exit with non zero exit code (${exitCode})`);
            }
            else {
                (0, prompter_1.stopSpinner)(`run ${picocolors_1.default.yellow(command + ' ' + args.join(' '))}`);
            }
        }
        catch (e) {
            (0, setState_1.setState)(action.name, {
                state: 'error',
                reason: (0, getErrMessage_1.getErrMessage)(e),
                error: true,
            });
            throw e;
        }
    }
}
exports.shellTask = shellTask;
exports.runTask = shellTask;
exports.summary = 'shell execution';
