"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.summary = exports.runTask = exports.mainApplicationTask = void 0;
const fs_1 = __importDefault(require("fs"));
const glob_1 = require("glob");
const constants_1 = require("../constants");
const applyContentModification_1 = require("../utils/applyContentModification");
const findClosingTagIndex_1 = require("../utils/findClosingTagIndex");
const getErrMessage_1 = require("../utils/getErrMessage");
const getProjectPath_1 = require("../utils/getProjectPath");
const satisfies_1 = require("../utils/satisfies");
const setState_1 = require("../utils/setState");
const stringSplice_1 = require("../utils/stringSplice");
const variables_1 = require("../variables");
async function mainApplicationTask(args) {
    let { content } = args;
    const { task, configPath, packageName } = args;
    for (const action of task.actions) {
        variables_1.variables.set('CONTENT', content);
        if (action.when && !(0, satisfies_1.satisfies)(variables_1.variables.getStore(), action.when)) {
            (0, setState_1.setState)(action.name, {
                state: 'skipped',
                reason: 'when',
                error: false,
            });
            continue;
        }
        (0, setState_1.setState)(action.name, {
            state: 'progress',
            error: false,
        });
        try {
            content = await (0, applyContentModification_1.applyContentModification)({
                action,
                findOrCreateBlock,
                configPath,
                packageName,
                content,
                indentation: 2,
            });
            (0, setState_1.setState)(action.name, {
                state: 'done',
                error: false,
            });
        }
        catch (e) {
            (0, setState_1.setState)(action.name, {
                state: 'error',
                reason: (0, getErrMessage_1.getErrMessage)(e),
                error: true,
            });
            throw e;
        }
    }
    return content;
}
exports.mainApplicationTask = mainApplicationTask;
function findOrCreateBlock(content, block) {
    let blockContent = {
        start: 0,
        end: content.length,
        match: content,
        space: '',
        justCreated: false,
    };
    const blockPath = block.split('.');
    let contentOffset = 0;
    for (let i = 0; i < blockPath.length; i++) {
        const matcherRegex = new RegExp(`^((\\s+)?)${blockPath[i]}\\s+\\{`, 'ms');
        let blockStart = matcherRegex.exec(blockContent.match);
        const justCreated = !blockStart;
        if (!blockStart) {
            const blockName = blockPath[i];
            // create block in block
            const space = ' '.repeat(2 * i);
            const previousSpace = ' '.repeat(Math.max(0, 2 * (i - 1)));
            const newBlock = `${space}${blockName} {}`;
            const codeToInsert = `
${newBlock}
${previousSpace}`;
            const contentLengthBeforeInsert = content.length;
            content = (0, stringSplice_1.stringSplice)(content, blockContent.end, 0, codeToInsert);
            if (codeToInsert.length && contentLengthBeforeInsert < content.length) {
                blockContent.match += codeToInsert;
                blockContent.end += codeToInsert.length;
                blockStart = matcherRegex.exec(blockContent.match);
            }
        }
        if (!blockStart) {
            throw new Error('block could not be inserted, something wrong?');
        }
        const blockEndIndex = (0, findClosingTagIndex_1.findClosingTagIndex)(content, contentOffset + blockStart.index + blockStart[0].length);
        const blockBody = content.substring(contentOffset + blockStart.index + blockStart[0].length, blockEndIndex);
        blockContent = {
            start: contentOffset + blockStart.index + blockStart[0].length,
            end: blockEndIndex,
            match: blockBody,
            justCreated,
            space: ' '.repeat(2 * i),
        };
        contentOffset += blockStart.index + blockStart[0].length;
    }
    return {
        blockContent,
        content,
    };
}
function getMainApplicationPath(lang) {
    const projectPath = (0, getProjectPath_1.getProjectPath)();
    const mainApplicationPath = (0, glob_1.globSync)([
        projectPath,
        'android',
        'app',
        'src',
        'main',
        'java',
        '**',
        lang === 'kotlin'
            ? constants_1.Constants.MAIN_APPLICATION_KT_FILE_NAME
            : constants_1.Constants.MAIN_APPLICATION_JAVA_FILE_NAME,
    ].join('/'), { nodir: true })[0];
    if (!mainApplicationPath)
        throw new Error(`MainApplication.${lang === 'kotlin' ? 'kt' : 'java'} file not found`);
    return mainApplicationPath;
}
function readMainApplicationContent(lang) {
    const mainApplicationPath = getMainApplicationPath(lang);
    return fs_1.default.readFileSync(mainApplicationPath, 'utf-8');
}
function writeAppDelegateContent(content, lang) {
    const mainApplicationPath = getMainApplicationPath(lang);
    return fs_1.default.writeFileSync(mainApplicationPath, content, 'utf-8');
}
async function runTask(args) {
    let content = readMainApplicationContent(args.task.lang);
    content = await mainApplicationTask({
        ...args,
        content,
    });
    writeAppDelegateContent(content, args.task.lang);
}
exports.runTask = runTask;
exports.summary = 'MainApplication modification';
