"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.summary = exports.runTask = exports.gitignoreTask = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("../constants");
const applyContentModification_1 = require("../utils/applyContentModification");
const getErrMessage_1 = require("../utils/getErrMessage");
const getProjectPath_1 = require("../utils/getProjectPath");
const satisfies_1 = require("../utils/satisfies");
const setState_1 = require("../utils/setState");
const variables_1 = require("../variables");
async function gitignoreTask(args) {
    let { content } = args;
    const { task, configPath, packageName } = args;
    for (const action of task.actions) {
        variables_1.variables.set('CONTENT', content);
        if (action.when && !(0, satisfies_1.satisfies)(variables_1.variables.getStore(), action.when)) {
            (0, setState_1.setState)(action.name, {
                state: 'skipped',
                reason: 'when',
                error: false,
            });
            continue;
        }
        (0, setState_1.setState)(action.name, {
            state: 'progress',
            error: false,
        });
        try {
            content = await (0, applyContentModification_1.applyContentModification)({
                action,
                findOrCreateBlock,
                configPath,
                packageName,
                content,
                indentation: 0,
                buildComment: buildGitignoreComment,
            });
            (0, setState_1.setState)(action.name, {
                state: 'done',
                error: false,
            });
        }
        catch (e) {
            (0, setState_1.setState)(action.name, {
                state: 'error',
                reason: (0, getErrMessage_1.getErrMessage)(e),
                error: true,
            });
            throw e;
        }
    }
    return content;
}
exports.gitignoreTask = gitignoreTask;
function findOrCreateBlock() {
    throw new Error('block is not supported in gitignore');
}
function buildGitignoreComment(comment) {
    return comment.split('\n').map(x => `# ${x}`);
}
function getGitignorePath() {
    const projectPath = (0, getProjectPath_1.getProjectPath)();
    return path_1.default.join(projectPath, constants_1.Constants.GITIGNORE_FILE_NAME);
}
function readGitignoreContent() {
    const gitignorePath = getGitignorePath();
    if (!fs_1.default.existsSync(gitignorePath))
        return '';
    return fs_1.default.readFileSync(gitignorePath, 'utf-8');
}
function writeGitignoreContent(content) {
    const gitignorePath = getGitignorePath();
    return fs_1.default.writeFileSync(gitignorePath, content, 'utf-8');
}
async function runTask(args) {
    let content = readGitignoreContent();
    content = await gitignoreTask({
        ...args,
        content,
    });
    writeGitignoreContent(content);
}
exports.runTask = runTask;
exports.summary = '.gitignore modification';
