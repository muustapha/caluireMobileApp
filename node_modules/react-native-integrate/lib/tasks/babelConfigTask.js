"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.summary = exports.runTask = exports.writeBabelConfigContent = exports.readBabelConfigContent = exports.babelParser = exports.getReducedContext = exports.shouldApplyInsertion = exports.babelConfigTask = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const picocolors_1 = __importDefault(require("picocolors"));
const prettier_1 = __importDefault(require("prettier"));
const constants_1 = require("../constants");
const prompter_1 = require("../prompter");
const applyContentModification_1 = require("../utils/applyContentModification");
const findClosingTagIndex_1 = require("../utils/findClosingTagIndex");
const findInsertionPoint_1 = require("../utils/findInsertionPoint");
const getErrMessage_1 = require("../utils/getErrMessage");
const getModContent_1 = require("../utils/getModContent");
const getProjectPath_1 = require("../utils/getProjectPath");
const satisfies_1 = require("../utils/satisfies");
const setState_1 = require("../utils/setState");
const stringSplice_1 = require("../utils/stringSplice");
const variables_1 = require("../variables");
async function babelConfigTask(args) {
    let { content } = args;
    const { task, configPath, packageName } = args;
    for (const action of task.actions) {
        if (action.when && !(0, satisfies_1.satisfies)(variables_1.variables.getStore(), action.when)) {
            (0, setState_1.setState)(action.name, {
                state: 'skipped',
                reason: 'when',
                error: false,
            });
            continue;
        }
        (0, setState_1.setState)(action.name, {
            state: 'progress',
            error: false,
        });
        try {
            if (action.block) {
                content = await applyArrayFieldModification({
                    configPath,
                    packageName,
                    content,
                    action,
                });
            }
            else {
                content = await (0, applyContentModification_1.applyContentModification)({
                    action,
                    findOrCreateBlock: undefined,
                    configPath,
                    packageName,
                    content,
                    indentation: 2,
                });
            }
            (0, setState_1.setState)(action.name, {
                state: 'done',
                error: false,
            });
        }
        catch (e) {
            (0, setState_1.setState)(action.name, {
                state: 'error',
                reason: (0, getErrMessage_1.getErrMessage)(e),
                error: true,
            });
            throw e;
        }
    }
    return content;
}
exports.babelConfigTask = babelConfigTask;
function shouldApplyInsertion(array, action, value) {
    if (action.ifNotPresent) {
        const { ifNotPresent } = action;
        if (array.some(x => x.includes(ifNotPresent))) {
            (0, prompter_1.logMessageGray)(`found existing ${(0, prompter_1.summarize)((0, variables_1.getText)(action.ifNotPresent))}, skipped adding: ${(0, prompter_1.summarize)(value)}`);
            (0, setState_1.setState)(action.name, {
                state: 'skipped',
                reason: 'insert.ifNotPresent',
                error: false,
            });
            return false;
        }
    }
    if (array.some(x => x.includes(value))) {
        (0, prompter_1.logMessageGray)(`code already exists, skipped adding: ${(0, prompter_1.summarize)(value)}`);
        (0, setState_1.setState)(action.name, {
            state: 'skipped',
            reason: 'insert.exists',
            error: false,
        });
        return false;
    }
    return true;
}
exports.shouldApplyInsertion = shouldApplyInsertion;
function getReducedContext(array, action) {
    let contextStart = 0;
    let contextEnd = array.length;
    // context reduction
    for (const key of Object.keys(action)) {
        let foundIndex;
        switch (key) {
            case 'before':
                foundIndex = array.findIndex(x => (0, findInsertionPoint_1.findInsertionPoint)(x, action.before).start != -1);
                if (foundIndex == -1) {
                    if (action.strict)
                        throw new Error('Could not find insertion point');
                    else
                        (0, prompter_1.logMessageGray)(`insertion point not found, ignoring ${picocolors_1.default.yellow('before')} criteria`);
                }
                else
                    contextEnd = foundIndex;
                break;
            case 'after':
                foundIndex = array.findIndex(x => (0, findInsertionPoint_1.findInsertionPoint)(x, action.after).start != -1);
                if (foundIndex == -1) {
                    if (action.strict)
                        throw new Error('Could not find insertion point');
                    else
                        (0, prompter_1.logMessageGray)(`insertion point not found, ignoring ${picocolors_1.default.yellow('after')} criteria`);
                }
                else
                    contextStart = foundIndex + 1;
                break;
            case 'search':
                foundIndex = array.findIndex(x => (0, findInsertionPoint_1.findInsertionPoint)(x, action.search).start != -1);
                if (foundIndex == -1) {
                    if (action.strict)
                        throw new Error('Could not find insertion point');
                    else
                        (0, prompter_1.logMessageGray)(`insertion point not found, ignoring ${picocolors_1.default.yellow('search')} criteria`);
                }
                else {
                    contextStart = foundIndex;
                    contextEnd = foundIndex + 1;
                }
                break;
        }
    }
    return [contextStart, contextEnd];
}
exports.getReducedContext = getReducedContext;
async function applyArrayFieldModification(args) {
    const { action, configPath, packageName } = args;
    const { content } = args;
    const babelContent = exports.babelParser.parse(content);
    const block = action.block;
    const [contextStart, contextEnd] = getReducedContext(babelContent[block], action);
    for (const key of Object.keys(action)) {
        let value;
        switch (key) {
            case 'prepend':
                value = await (0, getModContent_1.getModContent)(configPath, packageName, action.prepend);
                if (shouldApplyInsertion(babelContent[block], action, value)) {
                    babelContent[block].splice(contextStart, 0, value);
                }
                break;
            case 'append':
                value = await (0, getModContent_1.getModContent)(configPath, packageName, action.append);
                if (shouldApplyInsertion(babelContent[block], action, value)) {
                    babelContent[block].splice(contextEnd, 0, value);
                }
                break;
            case 'replace':
                value = await (0, getModContent_1.getModContent)(configPath, packageName, action.replace);
                if (shouldApplyInsertion(babelContent[block], action, value)) {
                    babelContent[block].splice(contextStart, 1, value);
                }
                break;
        }
    }
    return exports.babelParser.stringify(babelContent);
}
exports.babelParser = {
    _readArrayAsString(content, name) {
        const match = new RegExp(`${name}:\\s*\\[`).exec(content);
        if (!match)
            return [];
        const start = match.index + match[0].length;
        const end = (0, findClosingTagIndex_1.findClosingTagIndex)(content, start, findClosingTagIndex_1.TagDefinitions.BRACKETS);
        const bracketContent = content.substring(start, end);
        const strippedBracketContent = (0, findClosingTagIndex_1.stripNonCode)(bracketContent, findClosingTagIndex_1.TagDefinitions.BRACKETS.comment);
        const array = [];
        let nextItemStart = -1;
        for (let i = 0; i < strippedBracketContent.length; i++) {
            const char = strippedBracketContent[i];
            const isSplitter = char == ',';
            const isBracketStart = char == '[';
            const isCurlyStart = char == '{';
            if (nextItemStart == -1) {
                nextItemStart = i;
            }
            if (isBracketStart) {
                i = (0, findClosingTagIndex_1.findClosingTagIndex)(strippedBracketContent, i + 1, findClosingTagIndex_1.TagDefinitions.BRACKETS); // bracket end
            }
            if (isCurlyStart) {
                i = (0, findClosingTagIndex_1.findClosingTagIndex)(strippedBracketContent, i + 1, findClosingTagIndex_1.TagDefinitions.CURLY); // curly end
            }
            if (isSplitter) {
                array.push(bracketContent.substring(nextItemStart, i).replace(/\n/g, '').trim());
                nextItemStart = i + 1;
            }
        }
        if (nextItemStart != -1) {
            const lastItem = bracketContent
                .substring(nextItemStart)
                .replace(/\n/g, '')
                .trim();
            if (lastItem)
                array.push(lastItem);
        }
        return array;
    },
    _writeArrayAsString(content, name, array) {
        const currentArray = this._readArrayAsString(content, name);
        if (!currentArray.length && !array.length)
            return content;
        const match = new RegExp(`${name}:\\s*\\[`).exec(content);
        const arrayAsString = array
            .map(x => {
            // wrap string
            if (!['"', "'", '[', '{'].includes(x[0]))
                return `'${x}'`;
            return x;
        })
            .join(', ');
        if (!match) {
            const codeToInsert = `${name}: [${arrayAsString}]`;
            const exportsStart = /module.exports\s*=\s*{/.exec(content);
            if (!exportsStart)
                throw new Error('Could not find exports start');
            const exportsEnd = (0, findClosingTagIndex_1.findClosingTagIndex)(content, exportsStart.index + exportsStart[0].length, findClosingTagIndex_1.TagDefinitions.CURLY);
            return (0, stringSplice_1.stringSplice)(content, exportsEnd, 0, codeToInsert);
        }
        const start = match.index + match[0].length;
        const end = (0, findClosingTagIndex_1.findClosingTagIndex)(content, start, findClosingTagIndex_1.TagDefinitions.BRACKETS);
        return (0, stringSplice_1.stringSplice)(content, start, end - start, `${arrayAsString}`);
    },
    parse(content) {
        const presets = this._readArrayAsString(content, 'presets');
        const plugins = this._readArrayAsString(content, 'plugins');
        return { content, presets, plugins };
    },
    stringify(content) {
        const { content: contentString, presets, plugins } = content;
        const newContent = this._writeArrayAsString(contentString, 'presets', presets);
        return this._writeArrayAsString(newContent, 'plugins', plugins);
    },
};
function getBabelConfigPath() {
    const projectPath = (0, getProjectPath_1.getProjectPath)();
    const babelConfigPath = path_1.default.join(projectPath, constants_1.Constants.BABEL_CONFIG_FILE_NAME);
    if (!fs_1.default.existsSync(babelConfigPath))
        throw new Error(`babel.config.js file not found at ${babelConfigPath}`);
    return babelConfigPath;
}
function readBabelConfigContent() {
    const babelConfigPath = getBabelConfigPath();
    return fs_1.default.readFileSync(babelConfigPath, 'utf-8');
}
exports.readBabelConfigContent = readBabelConfigContent;
async function writeBabelConfigContent(content) {
    const babelConfigPath = getBabelConfigPath();
    let prettierConfig = await prettier_1.default.resolveConfig((0, getProjectPath_1.getProjectPath)());
    if (!prettierConfig)
        prettierConfig = {};
    if (!prettierConfig.parser)
        prettierConfig.parser = 'babel';
    content = await prettier_1.default.format(content, prettierConfig);
    return fs_1.default.writeFileSync(babelConfigPath, content, 'utf-8');
}
exports.writeBabelConfigContent = writeBabelConfigContent;
async function runTask(args) {
    let content = readBabelConfigContent();
    content = await babelConfigTask({
        ...args,
        content,
    });
    await writeBabelConfigContent(content);
}
exports.runTask = runTask;
exports.summary = 'babel.config.js modification';
