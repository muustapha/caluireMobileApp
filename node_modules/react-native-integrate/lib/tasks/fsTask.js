"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.summary = exports.runTask = exports.applyFsModification = exports.fsTask = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const picocolors_1 = __importDefault(require("picocolors"));
const prompter_1 = require("../prompter");
const copyPackageUpgradeFile_1 = require("../utils/copyPackageUpgradeFile");
const getErrMessage_1 = require("../utils/getErrMessage");
const getProjectPath_1 = require("../utils/getProjectPath");
const packageUpgradeConfig_1 = require("../utils/packageUpgradeConfig");
const satisfies_1 = require("../utils/satisfies");
const setState_1 = require("../utils/setState");
const waitForFile_1 = require("../utils/waitForFile");
const variables_1 = require("../variables");
async function fsTask(args) {
    const { task, packageName } = args;
    for (const action of task.actions) {
        if (action.when && !(0, satisfies_1.satisfies)(variables_1.variables.getStore(), action.when)) {
            (0, setState_1.setState)(action.name, {
                state: 'skipped',
                reason: 'when',
                error: false,
            });
            continue;
        }
        (0, setState_1.setState)(action.name, {
            state: 'progress',
            error: false,
        });
        try {
            await applyFsModification(action, packageName);
            (0, setState_1.setState)(action.name, {
                state: 'done',
                error: false,
            });
        }
        catch (e) {
            (0, setState_1.setState)(action.name, {
                state: 'error',
                reason: (0, getErrMessage_1.getErrMessage)(e),
                error: true,
            });
            throw e;
        }
    }
}
exports.fsTask = fsTask;
async function applyFsModification(action, packageName) {
    if (action.copyFile) {
        if ((0, copyPackageUpgradeFile_1.handlePackageUpgradeCopyFile)(packageName, (0, variables_1.getText)(action.destination))) {
            return;
        }
        action.copyFile = (0, variables_1.getText)(action.copyFile);
        const file = await (0, prompter_1.text)(action.message || `enter the path of ${action.copyFile} to copy`, {
            placeholder: 'leave empty do it manually',
        });
        variables_1.variables.set('FILE_NAME', action.copyFile);
        if (file) {
            const fileName = path_1.default.basename(file);
            variables_1.variables.set('FILE_NAME', fileName);
            action.destination = (0, variables_1.getText)(action.destination);
            const projectPath = (0, getProjectPath_1.getProjectPath)();
            const destination = path_1.default.join(projectPath, action.destination);
            // security check
            if (!destination.startsWith(projectPath)) {
                throw new Error('invalid destination path');
            }
            fs_1.default.copyFileSync(file, destination);
            (0, prompter_1.logMessage)(`copied ${picocolors_1.default.yellow(file)} to ${picocolors_1.default.yellow(action.destination)}`);
        }
        else {
            // user copying manually
            action.destination = (0, variables_1.getText)(action.destination);
            const destination = path_1.default.join((0, getProjectPath_1.getProjectPath)(), action.destination);
            // wait for file creation
            let fileExists;
            try {
                fileExists = await (0, waitForFile_1.waitForFile)(destination);
            }
            catch (e) {
                if ((0, getErrMessage_1.getErrMessage)(e) == 'skip') {
                    (0, prompter_1.logMessageGray)('skipped copy operation');
                    return;
                }
                else
                    throw e;
            }
            if (!fileExists) {
                const confirmed = await (0, prompter_1.confirm)(`confirm after manually updating the file at ${picocolors_1.default.yellow(action.destination)}`, {
                    positive: 'done',
                    negative: 'skip',
                    initialValue: true,
                });
                if (!confirmed) {
                    (0, prompter_1.logMessageGray)('skipped copy operation');
                }
                else
                    (0, prompter_1.logMessage)(`file was updated at ${picocolors_1.default.yellow(destination)}`);
            }
        }
        (0, packageUpgradeConfig_1.addPackageUpgradeFile)(packageName, action.destination);
    }
}
exports.applyFsModification = applyFsModification;
async function runTask(args) {
    return fsTask(args);
}
exports.runTask = runTask;
exports.summary = 'File system operation';
