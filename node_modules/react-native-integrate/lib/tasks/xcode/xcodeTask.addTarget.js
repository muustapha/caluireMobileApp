"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyAddTarget = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const picocolors_1 = __importDefault(require("picocolors"));
const constants_1 = require("../../constants");
const prompter_1 = require("../../prompter");
const notification_content_1 = require("../../scaffold/notification-content");
const notification_service_1 = require("../../scaffold/notification-service");
const getProjectPath_1 = require("../../utils/getProjectPath");
const runPrompt_1 = require("../../utils/runPrompt");
const variables_1 = require("../../variables");
const xcodeTask_helpers_1 = require("./xcodeTask.helpers");
async function applyAddTarget(content, action, packageName) {
    const { type } = action;
    action.addTarget = (0, variables_1.getText)(action.addTarget);
    await (0, runPrompt_1.runPrompt)({
        name: action.name + '.target',
        text: action.message || 'Enter new target name:',
        type: 'text',
        defaultValue: action.addTarget,
        placeholder: action.addTarget,
    }, packageName);
    let targetName = variables_1.variables.get(action.name + '.target');
    if (!targetName)
        targetName = action.addTarget;
    const mainGroup = content.getFirstProject().firstProject.mainGroup;
    const groupObj = content.getPBXGroupByKey(mainGroup);
    if (groupObj.children.some(x => (0, xcodeTask_helpers_1.unquote)(x.comment) == targetName)) {
        (0, prompter_1.logMessageGray)(`skipped adding target, ${picocolors_1.default.yellow(targetName)} is already exists`);
        return content;
    }
    const targetDir = path_1.default.join((0, getProjectPath_1.getProjectPath)(), 'ios', targetName);
    const nativeTarget = content.getTarget(constants_1.Constants.XCODE_APPLICATION_TYPE);
    if (!fs_1.default.existsSync(targetDir))
        fs_1.default.mkdirSync(targetDir);
    switch (type) {
        case 'notification-service':
            (() => {
                const files = notification_service_1.notificationServiceFiles;
                const extFiles = Object.keys(files);
                // Add a target for the extension
                let bundleId = content.getBuildProperty('PRODUCT_BUNDLE_IDENTIFIER', 'Release', nativeTarget.target.name);
                if (bundleId) {
                    bundleId = (0, xcodeTask_helpers_1.normalizeBundleId)(bundleId, {
                        productName: nativeTarget.target.name,
                    });
                    bundleId += '.' + targetName;
                }
                const target = content.addExtensionTarget(targetName, 'app_extension', '', {
                    bundleId,
                    team: content.getBuildProperty('DEVELOPMENT_TEAM', 'Release', nativeTarget.target.name),
                    codeSign: content.getBuildProperty('CODE_SIGN_IDENTITY', 'Release', nativeTarget.target.name),
                });
                // Create new PBXGroup for the extension
                const extGroup = content.addPbxGroup([], targetName, targetName);
                const releaseHasFilesPatch = (0, xcodeTask_helpers_1.patchXcodeHasFile)();
                try {
                    Object.entries(files).forEach(([name, fileContent]) => {
                        fs_1.default.writeFileSync(path_1.default.join(targetDir, name), fileContent, 'utf-8');
                        if (name.endsWith('.m'))
                            content.addExtensionSourceFile(name, {
                                target: target.uuid,
                            }, extGroup.uuid);
                        else if (name.endsWith('.h'))
                            content.addHeaderFile(name, {
                                target: target.uuid,
                            }, extGroup.uuid);
                        else
                            content.addFile(name, extGroup.uuid, {
                                target: target.uuid,
                            });
                    });
                }
                finally {
                    releaseHasFilesPatch();
                }
                // Add the new PBXGroup to the main group. This makes the
                // files appear in the file explorer in Xcode.
                const releasePatch = (0, xcodeTask_helpers_1.patchXcodeProject)({
                    push: (array, item, arrayPushOriginal) => {
                        const productsIndex = array.findIndex(x => x.comment == 'Products');
                        if (productsIndex > -1)
                            array.splice(productsIndex, 0, item);
                        else
                            arrayPushOriginal.call(array, item);
                        return array.length;
                    },
                });
                try {
                    content.addToPbxGroup(extGroup.uuid, mainGroup);
                }
                finally {
                    releasePatch();
                }
                // Add build phases to the new target
                content.addBuildPhase(extFiles.filter(x => x.endsWith('.m')), 'PBXSourcesBuildPhase', 'Sources', target.uuid);
                content.addBuildPhase([], 'PBXResourcesBuildPhase', 'Resources', target.uuid);
                content.addBuildPhase([], 'PBXFrameworksBuildPhase', 'Frameworks', target.uuid);
            })();
            break;
        case 'notification-content':
            (() => {
                const files = notification_content_1.notificationContentFiles;
                // Add a target for the extension
                let bundleId = content.getBuildProperty('PRODUCT_BUNDLE_IDENTIFIER', 'Release', nativeTarget.target.name);
                if (bundleId) {
                    bundleId = (0, xcodeTask_helpers_1.normalizeBundleId)(bundleId, {
                        productName: nativeTarget.target.name,
                    });
                    bundleId += '.' + targetName;
                }
                const target = content.addExtensionTarget(targetName, 'app_extension', '', {
                    bundleId,
                    team: content.getBuildProperty('DEVELOPMENT_TEAM', 'Release', nativeTarget.target.name),
                    codeSign: content.getBuildProperty('CODE_SIGN_IDENTITY', 'Release', nativeTarget.target.name),
                });
                // Add build phases to the new target
                content.addBuildPhase([], 'PBXSourcesBuildPhase', 'Sources', target.uuid);
                content.addBuildPhase([], 'PBXFrameworksBuildPhase', 'Frameworks', target.uuid);
                content.addBuildPhase([], 'PBXResourcesBuildPhase', 'Resources', target.uuid);
                // Create new PBXGroup for the extension
                const extGroup = content.addPbxGroup([], targetName, targetName);
                const releaseHasFilesPatch = (0, xcodeTask_helpers_1.patchXcodeHasFile)();
                try {
                    Object.entries(files).forEach(([name, fileContent]) => {
                        if (name.endsWith('.m')) {
                            fs_1.default.writeFileSync(path_1.default.join(targetDir, name), fileContent, 'utf-8');
                            content.addSourceFile(name, {
                                target: target.uuid,
                            }, extGroup.uuid);
                        }
                        else if (name.endsWith('.h')) {
                            fs_1.default.writeFileSync(path_1.default.join(targetDir, name), fileContent, 'utf-8');
                            content.addHeaderFile(name, {
                                target: target.uuid,
                            }, extGroup.uuid);
                        }
                        else if (name.endsWith('.lproj')) {
                            if (!fs_1.default.existsSync(path_1.default.join(targetDir, name)))
                                fs_1.default.mkdirSync(path_1.default.join(targetDir, name));
                            Object.entries(fileContent).forEach(([childName, childFileContent]) => {
                                if (childName.endsWith('.storyboard')) {
                                    fs_1.default.writeFileSync(path_1.default.join(targetDir, name, childName), childFileContent, 'utf-8');
                                    const group = content.addExtensionLocalizationVariantGroup(childName, target.uuid);
                                    content.addToPbxGroup(group, extGroup.uuid);
                                    content.addExtensionResourceFile(name + '/' + childName, {
                                        target: target.uuid,
                                        lastKnownFileType: 'file.storyboard',
                                        variantGroup: true,
                                    }, group.fileRef);
                                }
                            });
                        }
                        else {
                            fs_1.default.writeFileSync(path_1.default.join(targetDir, name), fileContent, 'utf-8');
                            content.addFile(name, extGroup.uuid, {
                                target: target.uuid,
                            });
                        }
                    });
                }
                finally {
                    releaseHasFilesPatch();
                }
                // Add the new PBXGroup to the main group. This makes the
                // files appear in the file explorer in Xcode.
                const releasePatch = (0, xcodeTask_helpers_1.patchXcodeProject)({
                    push: (array, item, arrayPushOriginal) => {
                        const productsIndex = array.findIndex(x => x.comment == 'Products');
                        if (productsIndex > -1)
                            array.splice(productsIndex, 0, item);
                        else
                            arrayPushOriginal.call(array, item);
                        return array.length;
                    },
                });
                try {
                    content.addToPbxGroup(extGroup.uuid, mainGroup);
                }
                finally {
                    releasePatch();
                }
                content.addFramework('UserNotifications.framework', {
                    target: target.uuid,
                });
                content.addFramework('UserNotificationsUI.framework', {
                    target: target.uuid,
                });
            })();
            break;
    }
    (0, prompter_1.logMessage)(`added ${picocolors_1.default.yellow(targetName)} extension to the project`);
    return content;
}
exports.applyAddTarget = applyAddTarget;
