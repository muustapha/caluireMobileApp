"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyAddConfiguration = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const picocolors_1 = __importDefault(require("picocolors"));
const constants_1 = require("../../constants");
const prompter_1 = require("../../prompter");
const getModContent_1 = require("../../utils/getModContent");
const getProjectPath_1 = require("../../utils/getProjectPath");
const xcodeTask_helpers_1 = require("./xcodeTask.helpers");
async function applyAddConfiguration(content, action, configPath, packageName) {
    const nativeTarget = content.getTarget(constants_1.Constants.XCODE_APPLICATION_TYPE);
    const group = content.getFirstProject().firstProject.mainGroup;
    const logTarget = 'project root';
    const buildConfigurationLists = content.pbxXCConfigurationList();
    const buildConfigurationList = buildConfigurationLists[content.getFirstProject().firstProject.buildConfigurationList];
    const buildConfigurationSection = content.pbxXCBuildConfigurationSection();
    const processedFiles = [];
    let createdFile = null;
    const projectPath = (0, getProjectPath_1.getProjectPath)();
    let configurationContent = await (0, getModContent_1.getModContent)(configPath, packageName, action.addConfiguration);
    if (!configurationContent.endsWith('\n'))
        configurationContent += '\n';
    for (const buildConfiguration of buildConfigurationList.buildConfigurations) {
        const id = buildConfiguration.value;
        const buildConfig = buildConfigurationSection[id];
        if (buildConfig.baseConfigurationReference) {
            // config exists
            const fileRefSection = content.pbxFileReferenceSection();
            const fileRef = fileRefSection[buildConfig.baseConfigurationReference];
            const filePath = path_1.default.join(projectPath, 'ios', (0, xcodeTask_helpers_1.unquote)(fileRef.path));
            if (!processedFiles.includes(filePath)) {
                processedFiles.push(filePath);
                let fileContent = fs_1.default.readFileSync(filePath, 'utf-8');
                if (fileContent.includes(configurationContent)) {
                    (0, prompter_1.logMessageGray)(`code already exists, skipped appending configuration: ${(0, prompter_1.summarize)(configurationContent)}`);
                }
                else {
                    if (fileContent && !fileContent.endsWith('\n'))
                        fileContent += '\n';
                    fileContent += configurationContent;
                    fs_1.default.writeFileSync(filePath, fileContent);
                    (0, prompter_1.logMessage)(`added ${(0, prompter_1.summarize)(configurationContent)} configuration in ${picocolors_1.default.yellow(fileRef.path)}`);
                }
            }
        }
        else {
            // config does not exist
            if (!createdFile) {
                const fileName = constants_1.Constants.XCConfig_FILE_NAME;
                const filePath = path_1.default.join(projectPath, 'ios', fileName);
                fs_1.default.writeFileSync(filePath, configurationContent);
                processedFiles.push(filePath);
                const groupObj = content.getPBXGroupByKey(group);
                const fileRefExists = groupObj.children.find(x => (0, xcodeTask_helpers_1.unquote)(x.comment) == fileName);
                if (fileRefExists) {
                    (0, prompter_1.logMessageGray)(`skipped adding resource, ${picocolors_1.default.yellow(fileName)} is already referenced in ${picocolors_1.default.yellow(logTarget)}`);
                    createdFile = {
                        fileRef: fileRefExists.value,
                        basename: fileRefExists.comment,
                    };
                }
                else {
                    const releasePatch = (0, xcodeTask_helpers_1.patchXcodeProject)({
                        push: (array, item) => array.unshift(item),
                    });
                    try {
                        createdFile = content.addResourceFile(fileName, { target: nativeTarget.uuid }, group);
                    }
                    finally {
                        releasePatch();
                    }
                    (0, prompter_1.logMessage)(`added ${(0, prompter_1.summarize)(configurationContent)} configuration in ${picocolors_1.default.yellow(fileName)}`);
                }
            }
            buildConfig.baseConfigurationReference = createdFile.fileRef;
            buildConfig.baseConfigurationReference_comment = createdFile.basename;
            (0, prompter_1.logMessage)(`set ${picocolors_1.default.yellow(createdFile.basename)} as base configuration for ${picocolors_1.default.yellow(buildConfiguration.comment)} build`);
        }
    }
    return content;
    //
    // destination += `/${fileName}`;
    // const groupObj = content.getPBXGroupByKey(group);
    // if (groupObj.children.some(x => x.comment == action.addConfiguration)) {
    //   logMessageGray(
    //     `skipped adding resource, ${color.yellow(
    //       action.addConfiguration
    //     )} is already referenced in ${color.yellow(logTarget)}`
    //   );
    //   return content;
    // }
    //
    // destination = path.join(projectPath, destination);
    // const configurationContent = await getModContent(configPath, packageName, action.addConfiguration)
    // fs.writeFileSync(destination, configurationContent);
    //
    // const releasePatch = patchXcodeProject({
    //   push: (array, item) => array.unshift(item),
    // });
    // try {
    //   content.addResourceFile(fileName, { target: nativeTarget.uuid }, group);
    // } finally {
    //   releasePatch();
    // }
    // logMessage(
    //   `added ${color.yellow(action.addConfiguration)} reference in ${color.yellow(
    //     logTarget
    //   )}`
    // );
    //
    // return content;
}
exports.applyAddConfiguration = applyAddConfiguration;
