"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.summary = exports.runTask = exports.appDelegateTask = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("../constants");
const applyContentModification_1 = require("../utils/applyContentModification");
const findClosingTagIndex_1 = require("../utils/findClosingTagIndex");
const getErrMessage_1 = require("../utils/getErrMessage");
const getIosProjectPath_1 = require("../utils/getIosProjectPath");
const satisfies_1 = require("../utils/satisfies");
const setState_1 = require("../utils/setState");
const stringSplice_1 = require("../utils/stringSplice");
const variables_1 = require("../variables");
async function appDelegateTask(args) {
    let { content } = args;
    const { task, configPath, packageName } = args;
    for (const action of task.actions) {
        variables_1.variables.set('CONTENT', content);
        if (action.when && !(0, satisfies_1.satisfies)(variables_1.variables.getStore(), action.when)) {
            (0, setState_1.setState)(action.name, {
                state: 'skipped',
                reason: 'when',
                error: false,
            });
            continue;
        }
        (0, setState_1.setState)(action.name, {
            state: 'progress',
            error: false,
        });
        try {
            content = await (0, applyContentModification_1.applyContentModification)({
                action,
                findOrCreateBlock,
                configPath,
                packageName,
                content,
                indentation: 2,
            });
            (0, setState_1.setState)(action.name, {
                state: 'done',
                error: false,
            });
        }
        catch (e) {
            (0, setState_1.setState)(action.name, {
                state: 'error',
                reason: (0, getErrMessage_1.getErrMessage)(e),
                error: true,
            });
            throw e;
        }
    }
    return content;
}
exports.appDelegateTask = appDelegateTask;
function findOrCreateBlock(content, block) {
    let blockContent = {
        start: 0,
        end: content.length,
        match: content,
        space: '',
        justCreated: false,
    };
    const blockDefinition = blockDefinitions[block];
    if (!blockDefinition)
        throw new Error(`Invalid block: ${block}`);
    const { regex, makeNewMethod } = blockDefinition;
    let blockStart = regex.exec(content);
    const justCreated = !blockStart;
    if (!blockStart) {
        const newMethod = makeNewMethod();
        content = appendNewMethod(content, newMethod);
        blockStart = regex.exec(content);
    }
    if (!blockStart) {
        throw new Error('block could not be inserted, something wrong?');
    }
    const blockEndIndex = (0, findClosingTagIndex_1.findClosingTagIndex)(content, blockStart.index + blockStart[0].length);
    const blockBody = content.substring(blockStart.index + blockStart[0].length, blockEndIndex);
    blockContent = {
        start: blockStart.index + blockStart[0].length,
        end: blockEndIndex,
        match: blockBody,
        justCreated,
        space: '',
    };
    return {
        blockContent,
        content,
    };
}
const blockDefinitions = {
    didFinishLaunchingWithOptions: {
        regex: /didFinishLaunchingWithOptions.*?\{/s,
        makeNewMethod: () => {
            throw new Error('didFinishLaunchingWithOptions not implemented, something is wrong?');
        },
    },
    applicationDidBecomeActive: {
        regex: /applicationDidBecomeActive.*?\{/s,
        makeNewMethod: () => {
            return '- (void)applicationDidBecomeActive:(UIApplication *)application {}';
        },
    },
    applicationWillResignActive: {
        regex: /applicationWillResignActive.*?\{/s,
        makeNewMethod: () => {
            return '- (void)applicationWillResignActive:(UIApplication *)application {}';
        },
    },
    applicationDidEnterBackground: {
        regex: /applicationDidEnterBackground.*?\{/s,
        makeNewMethod: () => {
            return '- (void)applicationDidEnterBackground:(UIApplication *)application {}';
        },
    },
    applicationWillEnterForeground: {
        regex: /applicationWillEnterForeground.*?\{/s,
        makeNewMethod: () => {
            return '- (void)applicationWillEnterForeground:(UIApplication *)application {}';
        },
    },
    applicationWillTerminate: {
        regex: /applicationWillTerminate.*?\{/s,
        makeNewMethod: () => {
            return '- (void)applicationWillTerminate:(UIApplication *)application {}';
        },
    },
    openURL: {
        regex: /openURL:.*?options:.*?\{/s,
        makeNewMethod: () => {
            // noinspection SpellCheckingInspection
            return '- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary<UIApplicationOpenURLOptionsKey,id> *)options {}';
        },
    },
    restorationHandler: {
        regex: /continueUserActivity:.*?restorationHandler:.*?\{/s,
        makeNewMethod: () => {
            return '- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray *))restorationHandler {}';
        },
    },
    didRegisterForRemoteNotificationsWithDeviceToken: {
        regex: /didRegisterForRemoteNotificationsWithDeviceToken.*?\{/s,
        makeNewMethod: () => {
            return '- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {}';
        },
    },
    didFailToRegisterForRemoteNotificationsWithError: {
        regex: /didFailToRegisterForRemoteNotificationsWithError.*?\{/s,
        makeNewMethod: () => {
            return '- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error {}';
        },
    },
    didReceiveRemoteNotification: {
        regex: /didReceiveRemoteNotification((?!fetchCompletionHandler).)*?\{/s,
        makeNewMethod: () => {
            return '- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo {}';
        },
    },
    fetchCompletionHandler: {
        regex: /didReceiveRemoteNotification:.*?fetchCompletionHandler:.*?\{/s,
        makeNewMethod: () => {
            return '- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler {}';
        },
    },
};
function appendNewMethod(content, newMethod) {
    const appDelegateMatch = /@implementation AppDelegate.*?@end/s.exec(content);
    if (!appDelegateMatch)
        throw new Error('Could not find @implementation AppDelegate');
    const codeToInsert = `${newMethod}

`;
    return (0, stringSplice_1.stringSplice)(content, appDelegateMatch.index + appDelegateMatch[0].length - 4, 0, codeToInsert);
}
function getAppDelegatePath() {
    const iosProjectPath = (0, getIosProjectPath_1.getIosProjectPath)();
    const appDelegatePath = path_1.default.join(iosProjectPath, constants_1.Constants.APP_DELEGATE_FILE_NAME);
    if (!fs_1.default.existsSync(appDelegatePath))
        throw new Error(`AppDelegate file not found at ${appDelegatePath}`);
    return appDelegatePath;
}
function readAppDelegateContent() {
    const appDelegatePath = getAppDelegatePath();
    return fs_1.default.readFileSync(appDelegatePath, 'utf-8');
}
function writeAppDelegateContent(content) {
    const appDelegatePath = getAppDelegatePath();
    return fs_1.default.writeFileSync(appDelegatePath, content, 'utf-8');
}
async function runTask(args) {
    let content = readAppDelegateContent();
    content = await appDelegateTask({
        ...args,
        content,
    });
    writeAppDelegateContent(content);
}
exports.runTask = runTask;
exports.summary = 'AppDelegate.mm modification';
