"use strict";
/* eslint-disable @typescript-eslint/no-unsafe-call */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeMockAndroidManifest = exports.writeMockJson = exports.writeMockPList = exports.writeMockNotificationContent = exports.writeMockNotificationService = exports.writeMockAppDelegate = exports.writeMockLock = exports.writeMockProject = exports.mockPrompter = exports.mockGlob = exports.mockFs = void 0;
require('./mockProjectPath');
require('./mockFetch');
const { mockPrompter } = require('./mockPrompter');
exports.mockPrompter = mockPrompter;
const { mockFs } = require('./mockFs');
exports.mockFs = mockFs;
const { mockGlob } = require('./mockGlob');
exports.mockGlob = mockGlob;
const path_1 = __importDefault(require("path"));
const constants_1 = require("../../constants");
const mockAndroidManifestTemplate_1 = require("./mockAndroidManifestTemplate");
const mockAppDelegateTemplate_1 = require("./mockAppDelegateTemplate");
const mockPList_1 = require("./mockPList");
const notificationServiceM_1 = require("../../scaffold/notification-service/notificationServiceM");
const notificationViewControllerM_1 = require("../../scaffold/notification-content/notificationViewControllerM");
jest.spyOn(process, 'abort').mockImplementation(() => {
    throw new Error('program aborted');
});
function writeMockProject(projectJson, name = 'mock-project') {
    const packageJsonPath = path_1.default.resolve(__dirname, `../${name}/${constants_1.Constants.PACKAGE_JSON_FILE_NAME}`);
    mockFs.writeFileSync(packageJsonPath, JSON.stringify(projectJson, null, 2));
    return packageJsonPath;
}
exports.writeMockProject = writeMockProject;
function writeMockLock(lockData, name = 'mock-project') {
    const lockPath = path_1.default.resolve(__dirname, `../${name}/${constants_1.Constants.LOCK_FILE_NAME}`);
    mockFs.writeFileSync(lockPath, JSON.stringify(lockData, null, 2));
    return lockPath;
}
exports.writeMockLock = writeMockLock;
function writeMockAppDelegate(appDelegateContent = mockAppDelegateTemplate_1.mockAppDelegateTemplate, name = 'mock-project') {
    const appDelegatePath = path_1.default.resolve(__dirname, `../${name}/ios/test/${constants_1.Constants.APP_DELEGATE_FILE_NAME}`);
    mockFs.writeFileSync(appDelegatePath, appDelegateContent);
    return appDelegatePath;
}
exports.writeMockAppDelegate = writeMockAppDelegate;
function writeMockNotificationService(notificationServiceContent = notificationServiceM_1.notificationServiceM, name = 'mock-project') {
    const notificationServicePath = path_1.default.resolve(__dirname, `../${name}/ios/test/${constants_1.Constants.NOTIFICATION_SERVICE_FILE_NAME}`);
    mockFs.writeFileSync(notificationServicePath, notificationServiceContent);
    return notificationServicePath;
}
exports.writeMockNotificationService = writeMockNotificationService;
function writeMockNotificationContent(notificationContentContent = notificationViewControllerM_1.notificationViewControllerM, name = 'mock-project') {
    const notificationContentPath = path_1.default.resolve(__dirname, `../${name}/ios/test/${constants_1.Constants.NOTIFICATION_VIEW_CONTROLLER_FILE_NAME}`);
    mockFs.writeFileSync(notificationContentPath, notificationContentContent);
    return notificationContentPath;
}
exports.writeMockNotificationContent = writeMockNotificationContent;
function writeMockPList(target = 'test') {
    const plistPath = path_1.default.resolve(__dirname, `../mock-project/ios/${target}/${constants_1.Constants.PLIST_FILE_NAME}`);
    mockFs.writeFileSync(plistPath, mockPList_1.mockPList);
    return plistPath;
}
exports.writeMockPList = writeMockPList;
function writeMockJson(filePath = 'test.json') {
    const jsonPath = path_1.default.resolve(__dirname, `../mock-project/${filePath}`);
    mockFs.writeFileSync(jsonPath, JSON.stringify({
        mock: 'test',
    }));
    return jsonPath;
}
exports.writeMockJson = writeMockJson;
function writeMockAndroidManifest() {
    const manifestPath = path_1.default.resolve(__dirname, `../mock-project/${constants_1.Constants.ANDROID_MAIN_FILE_PATH}/${constants_1.Constants.ANDROID_MANIFEST_FILE_NAME}`);
    mockFs.writeFileSync(manifestPath, mockAndroidManifestTemplate_1.mockAndroidManifestTemplate);
    return manifestPath;
}
exports.writeMockAndroidManifest = writeMockAndroidManifest;
let didSetup = false;
let mock;
if (!didSetup) {
    beforeAll(() => {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        mock = jest.spyOn(console, 'error').mockImplementation(() => { });
    });
    afterAll(() => {
        mock.mockClear();
    });
    beforeEach(() => {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        mockFs.reset();
        // add package.json to mockFs
        writeMockProject({
            name: 'mock-project',
            version: '0.0.0',
            description: 'Mock project',
            dependencies: {
                'mock-package': '^1.2.3',
                'react-native': '^1.2.3',
            },
            engines: {
                node: '>=16',
            },
        });
    });
    didSetup = true;
}
