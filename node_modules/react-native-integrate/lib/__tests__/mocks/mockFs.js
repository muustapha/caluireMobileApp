"use strict";
// noinspection JSUnusedGlobalSymbols
Object.defineProperty(exports, "__esModule", { value: true });
exports.mockFs = void 0;
const constants_1 = require("../../constants");
const escapeRegExp_1 = require("../../utils/escapeRegExp");
let store = {};
const permissions = {
    read: true,
    write: true,
};
function isDirectoryMatch(path, directory) {
    return new RegExp((0, escapeRegExp_1.escapeRegExp)(directory) + '(?:/|$)', 'i').test(path);
}
exports.mockFs = {
    existsSync: (path) => Object.keys(store).some(key => isDirectoryMatch(key, path)),
    renameSync: (from, to) => {
        Object.entries(store)
            .filter(([key]) => isDirectoryMatch(key, from))
            .forEach(([key, value]) => {
            store[key.replace(from, to)] = value;
            delete store[key];
        });
    },
    readFileSync: (path) => {
        if (!permissions.read)
            throw new Error('[mock] permission denied');
        if (!(path in store))
            throw new Error('[mock] file not found');
        return store[path];
    },
    writeFileSync: (path, data) => {
        if (!permissions.write)
            throw new Error('[mock] permission denied');
        store[path] = data;
        return true;
    },
    copyFileSync: (from, to) => {
        const content = exports.mockFs.readFileSync(from);
        exports.mockFs.writeFileSync(to, content);
        return true;
    },
    copyFile: jest.fn((from, to, cb) => {
        exports.mockFs.copyFileSync(from, to);
        cb();
    }),
    mkdirSync: () => {
        return true;
    },
    rmdirSync: (_path) => {
        Object.keys(store)
            .filter(key => isDirectoryMatch(key, _path))
            .forEach(key => delete store[key]);
        return true;
    },
    rmdir: jest.fn((_path, _opts, cb) => {
        exports.mockFs.rmdirSync(_path);
        cb();
    }),
    mkdir: jest.fn((_path, _opts, cb) => cb()),
    readdirSync: () => {
        return ['test' + constants_1.Constants.XCODEPROJ_EXT];
    },
    readdir: jest.fn(),
    unlink: jest.fn((filePath, cb) => {
        delete store[filePath];
        cb();
    }),
    lstatSync: jest.fn((p) => {
        if (Object.keys(store).includes(p)) {
            return {
                isFile: () => true,
                isDirectory: () => false,
            };
        }
        else if (Object.keys(store).some(key => isDirectoryMatch(key, p))) {
            return {
                isFile: () => false,
                isDirectory: () => true,
            };
        }
        else {
            throw new Error('[mock] file not found');
        }
    }),
    watch: (_filePath, 
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    _opts, listener) => {
        if (!permissions.read)
            throw new Error('[mock] permission denied');
        // simulate created
        setImmediate(() => listener('rename', 'file.json'));
        return {
            close: jest.fn(),
        };
    },
    reset() {
        store = {};
        permissions.read = true;
        permissions.write = true;
    },
    getStore() {
        return store;
    },
    setReadPermission(value) {
        permissions.read = value;
    },
    setWritePermission(value) {
        permissions.write = value;
    },
    get permissions() {
        return permissions;
    },
};
jest.mock('fs', () => exports.mockFs);
