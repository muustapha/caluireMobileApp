"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require('../../../mocks/mockAll');
const mockRunTask = jest.spyOn(require('../../../../utils/runTask'), 'runTask');
const path_1 = __importDefault(require("path"));
const getProjectPath_1 = require("../../../../utils/getProjectPath");
const runUpgradeTasks_1 = require("../../../../utils/upgrade/runUpgradeTasks");
const mockFs_1 = require("../../../mocks/mockFs");
describe('runUpgradeTasks', () => {
    afterEach(() => {
        mockRunTask.mockReset();
    });
    it('should execute upgrade.yml tasks', async () => {
        mockRunTask.mockResolvedValueOnce(undefined);
        mockFs_1.mockFs.writeFileSync(path_1.default.join((0, getProjectPath_1.getProjectPath)(), '.upgrade/upgrade.yml'), `
env:
  value: true
steps:
  - task: app_delegate
    label: AppDelegate.mm modification
    actions:
      - append: test`);
        const result = await (0, runUpgradeTasks_1.runUpgradeTasks)(undefined);
        expect(result.didRun).toBeTruthy();
        expect(mockRunTask).toHaveBeenCalledWith({
            configPath: path_1.default.join((0, getProjectPath_1.getProjectPath)(), '.upgrade/upgrade.yml'),
            packageName: 'upgrade.yml',
            task: {
                task: 'app_delegate',
                label: 'AppDelegate.mm modification',
                actions: [{ append: 'test' }],
            },
        });
    });
    it('should not execute when tasks does not meet condition', async () => {
        mockRunTask.mockResolvedValueOnce(undefined);
        mockFs_1.mockFs.writeFileSync(path_1.default.join((0, getProjectPath_1.getProjectPath)(), '.upgrade/upgrade.yml'), `
env:
  value: true
steps:
  - task: app_delegate
    when:
      value: false
    actions:
      - append: test`);
        const result = await (0, runUpgradeTasks_1.runUpgradeTasks)(undefined);
        expect(result.didRun).toBeTruthy();
        expect(mockRunTask).not.toHaveBeenCalled();
    });
    it('should handle not finding upgrade.yml', async () => {
        const result = await (0, runUpgradeTasks_1.runUpgradeTasks)(undefined);
        expect(result.didRun).toBeFalsy();
    });
    it('should handle invalid upgrade.yml', async () => {
        mockFs_1.mockFs.writeFileSync(path_1.default.join((0, getProjectPath_1.getProjectPath)(), '.upgrade/upgrade.yml'), 'random');
        const result = await (0, runUpgradeTasks_1.runUpgradeTasks)(undefined);
        expect(result.didRun).toBeFalsy();
    });
    it('should handle failed tasks', async () => {
        mockRunTask.mockRejectedValueOnce(new Error('random'));
        mockFs_1.mockFs.writeFileSync(path_1.default.join((0, getProjectPath_1.getProjectPath)(), '.upgrade/upgrade.yml'), `
steps:
  - task: app_delegate
    actions:
      - append: test`);
        const result = await (0, runUpgradeTasks_1.runUpgradeTasks)(undefined);
        expect(result.didRun).toBeTruthy();
        if (result.didRun) {
            expect(result.failedTaskCount).toBe(1);
        }
    });
    it('should execute upgrade.yml imports', async () => {
        mockFs_1.mockFs.writeFileSync('/oldProject/path/some.file', 'random');
        mockFs_1.mockFs.writeFileSync(path_1.default.join((0, getProjectPath_1.getProjectPath)(), '.upgrade/upgrade.yml'), `
imports:
  - path
  - path/some.file`);
        const result = await (0, runUpgradeTasks_1.runUpgradeTasks)('/oldProject');
        expect(result.didRun).toBeTruthy();
        expect(mockFs_1.mockFs.readFileSync((0, getProjectPath_1.getProjectPath)() + '/path/some.file')).toBe('random');
    });
    it('should skip non existing upgrade.yml imports', async () => {
        mockFs_1.mockFs.writeFileSync(path_1.default.join((0, getProjectPath_1.getProjectPath)(), '.upgrade/upgrade.yml'), `
imports:
  - path/some.file`);
        mockFs_1.mockFs.lstatSync.mockClear();
        const result = await (0, runUpgradeTasks_1.runUpgradeTasks)('/oldProject');
        expect(result.didRun).toBeTruthy();
        expect(mockFs_1.mockFs.lstatSync).not.toHaveBeenCalled();
    });
    it('should skip when no old project path specified', async () => {
        mockFs_1.mockFs.writeFileSync(path_1.default.join((0, getProjectPath_1.getProjectPath)(), '.upgrade/upgrade.yml'), `
imports:
  - path/some.file`);
        mockFs_1.mockFs.lstatSync.mockClear();
        const result = await (0, runUpgradeTasks_1.runUpgradeTasks)(undefined);
        expect(result.didRun).toBeTruthy();
        expect(mockFs_1.mockFs.lstatSync).not.toHaveBeenCalled();
    });
    it('should handle copy error', async () => {
        mockFs_1.mockFs.writeFileSync('/oldProject/path/some.file', 'random');
        mockFs_1.mockFs.writeFileSync(path_1.default.join((0, getProjectPath_1.getProjectPath)(), '.upgrade/upgrade.yml'), `
imports:
  - path/some.file`);
        mockFs_1.mockFs.copyFile.mockImplementationOnce((from, to, cb) => {
            cb(new Error('random'));
        });
        await expect((0, runUpgradeTasks_1.runUpgradeTasks)('/oldProject')).rejects.toThrow('random');
    });
});
