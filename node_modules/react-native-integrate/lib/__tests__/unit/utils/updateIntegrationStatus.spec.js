"use strict";
/* eslint-disable @typescript-eslint/no-unsafe-call */
// noinspection DuplicatedCode
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const { mockFs, writeMockLock } = require('../../mocks/mockAll');
const path_1 = __importDefault(require("path"));
const constants_1 = require("../../../constants");
const getProjectPath_1 = require("../../../utils/getProjectPath");
const updateIntegrationStatus_1 = require("../../../utils/updateIntegrationStatus");
describe('updateIntegrationStatus', () => {
    it('should create new lock file', () => {
        (0, updateIntegrationStatus_1.updateIntegrationStatus)([
            {
                packageName: 'test',
                lockProjectData: {
                    version: '1.2.3',
                    integrated: true,
                },
            },
        ]);
        const filePath = path_1.default.join((0, getProjectPath_1.getProjectPath)(), constants_1.Constants.LOCK_FILE_NAME);
        const fileContent = mockFs.readFileSync(filePath);
        expect(fileContent).toBeTruthy();
        const content = JSON.parse(fileContent);
        expect(content.packages).toEqual({
            test: {
                version: '1.2.3',
                integrated: true,
            },
        });
    });
    it('should update existing lock file', () => {
        const filePath = writeMockLock({
            lockfileVersion: constants_1.Constants.CURRENT_LOCK_VERSION,
            packages: {},
        });
        (0, updateIntegrationStatus_1.updateIntegrationStatus)([
            {
                packageName: 'test',
                lockProjectData: {
                    version: '1.2.3',
                    integrated: true,
                },
            },
        ]);
        const fileContent = mockFs.readFileSync(filePath);
        expect(fileContent).toBeTruthy();
        const content = JSON.parse(fileContent);
        expect(content.packages).toEqual({
            test: {
                version: '1.2.3',
                integrated: true,
            },
        });
    });
    it('should delete package', () => {
        const filePath = writeMockLock({
            lockfileVersion: constants_1.Constants.CURRENT_LOCK_VERSION,
            packages: {
                test: {
                    version: '1.2.3',
                    integrated: true,
                },
            },
        });
        (0, updateIntegrationStatus_1.updateIntegrationStatus)([
            {
                packageName: 'test',
                lockProjectData: {
                    version: '1.2.3',
                    integrated: true,
                    deleted: true,
                },
            },
        ]);
        const fileContent = mockFs.readFileSync(filePath);
        expect(fileContent).toBeTruthy();
        const content = JSON.parse(fileContent);
        expect(content.packages).toEqual({});
    });
    it('should update empty lock file', () => {
        const lockPath = path_1.default.resolve(__dirname, `../../mock-project/${constants_1.Constants.LOCK_FILE_NAME}`);
        mockFs.writeFileSync(lockPath, '');
        (0, updateIntegrationStatus_1.updateIntegrationStatus)([
            {
                packageName: 'test',
                lockProjectData: {
                    version: '1.2.3',
                    integrated: true,
                },
            },
        ]);
        const filePath = path_1.default.join((0, getProjectPath_1.getProjectPath)(), constants_1.Constants.LOCK_FILE_NAME);
        const fileContent = mockFs.readFileSync(filePath);
        expect(fileContent).toBeTruthy();
        const content = JSON.parse(fileContent);
        expect(content.packages).toEqual({
            test: {
                version: '1.2.3',
                integrated: true,
            },
        });
    });
    it('should update existing lock file with no packages field', () => {
        const filePath = writeMockLock({
            lockfileVersion: constants_1.Constants.CURRENT_LOCK_VERSION,
            packages: undefined,
        });
        (0, updateIntegrationStatus_1.updateIntegrationStatus)([
            {
                packageName: 'test',
                lockProjectData: {
                    version: '1.2.3',
                    integrated: true,
                },
            },
        ]);
        const fileContent = mockFs.readFileSync(filePath);
        expect(fileContent).toBeTruthy();
        const content = JSON.parse(fileContent);
        expect(content.packages).toEqual({
            test: {
                version: '1.2.3',
                integrated: true,
            },
        });
    });
    it('should abort for unsupported lock file version', () => {
        // @ts-ignore
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        writeMockLock({
            lockfileVersion: -1,
            packages: {},
        });
        expect(() => {
            (0, updateIntegrationStatus_1.updateIntegrationStatus)([
                {
                    packageName: 'test',
                    lockProjectData: {
                        version: '1.2.3',
                        integrated: true,
                    },
                },
            ]);
        }).toThrowError('program aborted');
    });
    it('should abort when has no read permission', () => {
        mockFs.setReadPermission(false);
        // @ts-ignore
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        writeMockLock({
            lockfileVersion: constants_1.Constants.CURRENT_LOCK_VERSION,
            packages: {},
        });
        expect(() => {
            (0, updateIntegrationStatus_1.updateIntegrationStatus)([
                {
                    packageName: 'test',
                    lockProjectData: {
                        version: '1.2.3',
                        integrated: true,
                    },
                },
            ]);
        }).toThrowError('program aborted');
    });
    it('should abort when has no write permission', () => {
        mockFs.setWritePermission(false);
        // @ts-ignore
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        expect(() => {
            (0, updateIntegrationStatus_1.updateIntegrationStatus)([
                {
                    packageName: 'test',
                    lockProjectData: {
                        version: '1.2.3',
                        integrated: true,
                    },
                },
            ]);
        }).toThrowError('program aborted');
    });
});
