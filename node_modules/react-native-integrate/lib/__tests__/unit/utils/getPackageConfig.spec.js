"use strict";
/* eslint-disable @typescript-eslint/no-unsafe-call */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const { mockFs } = require('../../mocks/mockAll');
const path_1 = __importDefault(require("path"));
const constants_1 = require("../../../constants");
const getPackageConfig_1 = require("../../../utils/getPackageConfig");
const mockIntegrateYml_1 = require("../../mocks/mockIntegrateYml");
describe('getRemotePath', () => {
    it('should return remote path correctly', () => {
        const packageName = '@react-native-firebase/app';
        const remotePath = (0, getPackageConfig_1.getRemotePath)(packageName);
        expect(remotePath).toContain('/1/a/b/%40react-native-firebase/app');
    });
});
describe('getPackageConfig', () => {
    beforeEach(() => {
        // @ts-ignore
        fetch.mockClear();
    });
    it('should download from remote repo', async () => {
        const packageName = '@react-native-firebase/app';
        const configPath = await (0, getPackageConfig_1.getPackageConfig)(packageName);
        expect(configPath).toBeTruthy();
        expect(fetch).toHaveBeenCalled();
    });
    it('should fail when config not available in remote repo', async () => {
        const packageName = '@react-native-firebase/fail';
        const configPath = await (0, getPackageConfig_1.getPackageConfig)(packageName);
        expect(configPath).toBeNull();
        expect(fetch).toHaveBeenCalled();
    });
    it('should use local config', async () => {
        const packageName = '@react-native-firebase/app';
        const localPackagePath = (0, getPackageConfig_1.getPackagePath)(packageName);
        const localConfigPath = path_1.default.join(localPackagePath, constants_1.Constants.CONFIG_FILE_NAME);
        mockFs.writeFileSync(localConfigPath, mockIntegrateYml_1.mockIntegrateYml);
        const configPath = await (0, getPackageConfig_1.getPackageConfig)(packageName);
        expect(configPath).toBeTruthy();
        expect(fetch).not.toHaveBeenCalled();
    });
});
