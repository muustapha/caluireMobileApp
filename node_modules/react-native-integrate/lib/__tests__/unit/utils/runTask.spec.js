"use strict";
/* eslint-disable @typescript-eslint/no-unsafe-call */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const { mockFs } = require('../../mocks/mockAll');
const mocks = {
    app_delegate: {
        runTask: jest.fn(),
    },
    plist: {
        runTask: jest.fn(),
    },
    build_gradle: {
        runTask: jest.fn(),
    },
    settings_gradle: {
        runTask: jest.fn(),
    },
    main_application: {
        runTask: jest.fn(),
    },
    main_activity: {
        runTask: jest.fn(),
    },
    xcode: {
        runTask: jest.fn(),
    },
    android_manifest: {
        runTask: jest.fn(),
    },
    podfile: {
        runTask: jest.fn(),
    },
    fs: {
        runTask: jest.fn(),
    },
    json: {
        runTask: jest.fn(),
    },
};
jest.mock('../../../tasks/appDelegateTask', () => mocks.app_delegate);
jest.mock('../../../tasks/plistTask', () => mocks.plist);
jest.mock('../../../tasks/buildGradleTask', () => mocks.build_gradle);
jest.mock('../../../tasks/settingsGradleTask', () => mocks.settings_gradle);
jest.mock('../../../tasks/mainApplicationTask', () => mocks.main_application);
jest.mock('../../../tasks/mainActivityTask', () => mocks.main_activity);
jest.mock('../../../tasks/xcode/xcodeTask', () => mocks.xcode);
jest.mock('../../../tasks/androidManifestTask', () => mocks.android_manifest);
jest.mock('../../../tasks/podFileTask', () => mocks.podfile);
jest.mock('../../../tasks/fsTask', () => mocks.fs);
jest.mock('../../../tasks/jsonTask', () => mocks.json);
const path_1 = __importDefault(require("path"));
const runTask_1 = require("../../../utils/runTask");
const mockIntegrateYml_1 = require("../../mocks/mockIntegrateYml");
describe('runTask', () => {
    [
        'app_delegate',
        'plist',
        'build_gradle',
        'xcode',
        'android_manifest',
        'podfile',
        'fs',
        'json',
    ].map(taskType => {
        it(`should run ${taskType} task`, async () => {
            mocks[taskType].runTask.mockReset();
            const integrateYmlPath = path_1.default.resolve(__dirname, '../mock-project/node_modules/test-package/integrate.yml');
            mockFs.writeFileSync(integrateYmlPath, mockIntegrateYml_1.mockIntegrateYml);
            const task = {
                task: taskType,
            };
            await (0, runTask_1.runTask)({
                configPath: integrateYmlPath,
                task,
                packageName: 'test',
            });
            expect(mocks[taskType].runTask).toHaveBeenCalledTimes(1);
        });
    });
});
