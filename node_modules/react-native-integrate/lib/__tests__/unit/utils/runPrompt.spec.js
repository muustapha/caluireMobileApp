"use strict";
/* eslint-disable @typescript-eslint/no-unsafe-call */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const { mockFs } = require('../../mocks/mockAll');
const path_1 = __importDefault(require("path"));
const getProjectPath_1 = require("../../../utils/getProjectPath");
const runPrompt_1 = require("../../../utils/runPrompt");
const variables_1 = require("../../../variables");
const mockAll_1 = require("../../mocks/mockAll");
describe('getValidate', () => {
    it('should get success validation fn', () => {
        const fn = (0, runPrompt_1.getValidate)([
            {
                regex: '.*test.*',
                message: 'must contain test',
            },
        ]);
        expect(fn).not.toBeUndefined();
        if (!fn)
            return;
        expect(fn('random test random')).toBeUndefined();
    });
    it('should get failed validation fn', () => {
        const fn = (0, runPrompt_1.getValidate)([
            {
                regex: '.*test.*',
                message: 'must contain test',
            },
        ]);
        expect(fn).not.toBeUndefined();
        if (!fn)
            return;
        expect(fn('random')).toBe('must contain test');
    });
    it('should handle undefined', () => {
        const fn = (0, runPrompt_1.getValidate)(undefined);
        expect(fn).toBeUndefined();
    });
});
describe('runPrompt', () => {
    it('should handle upgrade when input value is in upgrade.json', async () => {
        variables_1.variables.set('__UPGRADE__', true);
        mockFs.writeFileSync(path_1.default.join((0, getProjectPath_1.getProjectPath)(), '.upgrade', 'packages', 'test-package', 'upgrade.json'), JSON.stringify({
            inputs: {
                testInput: 'testValue',
            },
        }, null, 2));
        mockAll_1.mockPrompter.text.mockReset();
        await (0, runPrompt_1.runPrompt)({
            name: 'testInput',
            type: 'text',
            text: 'random',
        }, 'test-package');
        expect(mockAll_1.mockPrompter.text).not.toHaveBeenCalled();
        expect(variables_1.variables.get('testInput')).toBe('testValue');
        variables_1.variables.clear();
    });
});
