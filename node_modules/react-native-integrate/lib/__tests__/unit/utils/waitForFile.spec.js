"use strict";
/* eslint-disable @typescript-eslint/no-unsafe-call */
Object.defineProperty(exports, "__esModule", { value: true });
const { mockFs } = require('../../mocks/mockAll');
const mockStartSpinner = jest.spyOn(require('../../../prompter'), 'startSpinner');
const waitForFile_1 = require("../../../utils/waitForFile");
describe('waitForFile', () => {
    it('should resolve false when file exists', async () => {
        mockFs.writeFileSync('/test/file.json', 'test-content');
        await expect((0, waitForFile_1.waitForFile)('/test/file.json')).resolves.toBe(false);
    });
    it('should resolve true when file not exists', async () => {
        await expect((0, waitForFile_1.waitForFile)('/test/file.json')).resolves.toBe(true);
    });
    it('should throw when has no permission', async () => {
        mockFs.setReadPermission(false);
        await expect((0, waitForFile_1.waitForFile)('/test/file.json')).rejects.toThrowError('permission denied');
    });
    it('should throw when has no permission', async () => {
        mockFs.setReadPermission(false);
        await expect((0, waitForFile_1.waitForFile)('/test/file.json')).rejects.toThrowError('permission denied');
    });
    it('should handle cancel', async () => {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        mockStartSpinner.mockImplementationOnce(((msg, onCancel) => {
            setImmediate(() => onCancel());
        }));
        await expect((0, waitForFile_1.waitForFile)('/test/file.json')).rejects.toThrowError('skip');
        mockStartSpinner.mockReset();
    });
});
