"use strict";
/* eslint-disable @typescript-eslint/no-unsafe-call */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const { mockPrompter } = require('../mocks/mockAll');
const picocolors_1 = __importDefault(require("picocolors"));
const prompter_1 = require("../../prompter");
describe('prompter', () => {
    it('should log message', () => {
        mockPrompter.log.step.mockClear();
        (0, prompter_1.log)('test');
        expect(mockPrompter.log.step).toHaveBeenCalledWith(expect.stringContaining('test'));
    });
    it('should log success message', () => {
        mockPrompter.log.success.mockClear();
        (0, prompter_1.logSuccess)('test');
        expect(mockPrompter.log.success).toHaveBeenCalledWith(expect.stringContaining('test'));
    });
    it('should log bullet message', () => {
        mockPrompter.log.message.mockClear();
        (0, prompter_1.logMessage)('test');
        expect(mockPrompter.log.message).toHaveBeenCalledWith(expect.stringContaining('⦿ test'));
    });
    it('should log gray bullet message', () => {
        const spy = jest.spyOn(picocolors_1.default, 'gray');
        mockPrompter.log.message.mockClear();
        (0, prompter_1.logMessageGray)('test');
        expect(mockPrompter.log.message).toHaveBeenCalledWith(expect.stringContaining('⦿ test'));
        expect(spy).toHaveBeenCalled();
        spy.mockRestore();
    });
    it('should log warning message', () => {
        mockPrompter.log.warning.mockClear();
        (0, prompter_1.logWarning)('test');
        expect(mockPrompter.log.warning).toHaveBeenCalledWith(expect.stringContaining('test'));
    });
    it('should log warning message without color', () => {
        const spy = jest.spyOn(picocolors_1.default, 'yellow');
        (0, prompter_1.logWarning)('test', true);
        expect(spy).not.toHaveBeenCalled();
        spy.mockRestore();
    });
    it('should log info message', () => {
        mockPrompter.log.info.mockClear();
        (0, prompter_1.logInfo)('test');
        expect(mockPrompter.log.info).toHaveBeenCalledWith(expect.stringContaining('test'));
    });
    it('should log error message', () => {
        mockPrompter.log.error.mockClear();
        (0, prompter_1.logError)('test');
        expect(mockPrompter.log.error).toHaveBeenCalledWith(expect.stringContaining('test'));
    });
    it('should log error message without color', () => {
        const spy = jest.spyOn(picocolors_1.default, 'red');
        (0, prompter_1.logError)('test', true);
        expect(spy).not.toHaveBeenCalled();
        spy.mockRestore();
    });
    it('should log error message', () => {
        mockPrompter.note.mockClear();
        (0, prompter_1.logNote)('test1', 'test2');
        expect(mockPrompter.note).toHaveBeenCalledWith(expect.stringContaining('test1'), expect.stringContaining('test2'));
    });
    it('should log intro message', () => {
        mockPrompter.intro.mockClear();
        (0, prompter_1.logIntro)();
        expect(mockPrompter.intro).toHaveBeenCalled();
    });
    it('should log outro message', () => {
        mockPrompter.outro.mockClear();
        (0, prompter_1.logOutro)();
        expect(mockPrompter.outro).toHaveBeenCalled();
    });
    it('should start spinner', () => {
        const spinner = mockPrompter.spinner();
        spinner.start.mockClear();
        (0, prompter_1.startSpinner)('test');
        expect(spinner.start).toHaveBeenCalled();
    });
    it('should update spinner message', () => {
        const spinner = mockPrompter.spinner();
        spinner.message.mockClear();
        (0, prompter_1.updateSpinner)('test');
        expect(spinner.message).toHaveBeenCalled();
    });
    it('should stop spinner', () => {
        const spinner = mockPrompter.spinner();
        spinner.stop.mockClear();
        (0, prompter_1.stopSpinner)('test');
        expect(spinner.stop).toHaveBeenCalled();
    });
    it('should confirm', async () => {
        mockPrompter.confirm.mockClear();
        await (0, prompter_1.confirm)('test');
        expect(mockPrompter.confirm).toHaveBeenCalled();
    });
    it('should prompt multiselect', async () => {
        mockPrompter.multiselect.mockClear();
        const opts = await (0, prompter_1.multiselect)('test', {
            options: [{ value: 'opt1' }, { value: 'opt2' }],
        });
        expect(mockPrompter.multiselect).toHaveBeenCalled();
        expect(opts).toEqual(['opt1', 'opt2']);
    });
    it('should prompt select', async () => {
        mockPrompter.select.mockClear();
        const opts = await (0, prompter_1.select)('test', {
            options: [{ value: 'opt1' }, { value: 'opt2' }],
        });
        expect(mockPrompter.select).toHaveBeenCalled();
        expect(opts).toEqual('opt1');
    });
    it('should cancel confirm', async () => {
        mockPrompter.confirm.mockClear();
        mockPrompter.isCancel.mockImplementationOnce(() => true);
        // @ts-ignore
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        await expect(async () => {
            await (0, prompter_1.confirm)('test');
        }).rejects.toThrowError('program aborted');
        expect(mockPrompter.confirm).toHaveBeenCalled();
    });
    it('should cancel test', async () => {
        mockPrompter.text.mockClear();
        mockPrompter.isCancel.mockImplementationOnce(() => true);
        // @ts-ignore
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        await expect(async () => {
            await (0, prompter_1.text)('test');
        }).rejects.toThrowError('program aborted');
        expect(mockPrompter.text).toHaveBeenCalled();
    });
});
it('should cancel multiselect', async () => {
    mockPrompter.multiselect.mockClear();
    mockPrompter.isCancel.mockImplementationOnce(() => true);
    // @ts-ignore
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    await expect(async () => (0, prompter_1.multiselect)('test', {
        options: [{ value: 'opt1' }, { value: 'opt2' }],
    })).rejects.toThrowError('program aborted');
    expect(mockPrompter.multiselect).toHaveBeenCalled();
});
it('should cancel select', async () => {
    mockPrompter.select.mockClear();
    mockPrompter.isCancel.mockImplementationOnce(() => true);
    // @ts-ignore
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    await expect(async () => (0, prompter_1.select)('test', {
        options: [{ value: 'opt1' }, { value: 'opt2' }],
    })).rejects.toThrowError('program aborted');
    expect(mockPrompter.select).toHaveBeenCalled();
});
describe('summarize', () => {
    it('should shorten long text', () => {
        const text = 'a'.repeat(150);
        const shortText = 'a'.repeat(100) + '...';
        expect((0, prompter_1.summarize)(text, 100)).toContain(shortText);
    });
    it('should colorize to yellow', () => {
        const spy = jest.spyOn(picocolors_1.default, 'yellow');
        (0, prompter_1.summarize)('test');
        expect(spy).toHaveBeenCalled();
        spy.mockRestore();
    });
    it('should flat new lines', () => {
        // @ts-ignore
        jest.spyOn(picocolors_1.default, 'yellow').mockImplementationOnce(msg => msg);
        const summarized = (0, prompter_1.summarize)('test1\ntest2\ntest3');
        expect(summarized).toEqual('test1⏎test2⏎test3');
    });
    it('should support null', () => {
        // @ts-ignore
        jest.spyOn(picocolors_1.default, 'yellow').mockImplementationOnce(msg => msg);
        const summarized = (0, prompter_1.summarize)(null);
        expect(summarized).toEqual('null');
    });
});
