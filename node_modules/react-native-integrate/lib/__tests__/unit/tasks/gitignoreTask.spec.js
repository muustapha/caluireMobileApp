"use strict";
/* eslint-disable @typescript-eslint/no-unsafe-call */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const { mockFs, mockPrompter } = require('../../mocks/mockAll');
const path_1 = __importDefault(require("path"));
const constants_1 = require("../../../constants");
const gitignoreTask_1 = require("../../../tasks/gitignoreTask");
describe('gitignoreTask', () => {
    it('should prepend text into empty body ', async () => {
        let content = '';
        const task = {
            task: 'gitignore',
            actions: [
                {
                    append: 'ignoredfile',
                    prepend: 'ignoredfile',
                },
            ],
        };
        content = await (0, gitignoreTask_1.gitignoreTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        content = await (0, gitignoreTask_1.gitignoreTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        expect(content).toEqual(`
ignoredfile
`);
    });
    it('should prepend text into empty body without block', async () => {
        let content = '';
        const task = {
            task: 'gitignore',
            actions: [
                {
                    append: 'ignoredfile',
                    prepend: 'ignoredfile',
                },
            ],
        };
        content = await (0, gitignoreTask_1.gitignoreTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        content = await (0, gitignoreTask_1.gitignoreTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        expect(content).toEqual(`
ignoredfile
`);
    });
    it('should skip insert when ifNotPresent exists', async () => {
        const content = `
someignored
`;
        const task = {
            task: 'gitignore',
            actions: [
                {
                    ifNotPresent: 'someignored',
                    prepend: 'ignored',
                },
                {
                    ifNotPresent: 'someignored',
                    append: 'ignored',
                },
            ],
        };
        await (0, gitignoreTask_1.gitignoreTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        expect(mockPrompter.log.message).toHaveBeenCalledWith(expect.stringContaining('found existing '));
    });
    it('should prepend text into partial body ', async () => {
        let content = `
ignoredfile
`;
        const task = {
            task: 'gitignore',
            actions: [
                {
                    prepend: 'ignoredfile',
                },
            ],
        };
        content = await (0, gitignoreTask_1.gitignoreTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        expect(content).toEqual(`
ignoredfile
`);
    });
    it('should append text into existing body ', async () => {
        let content = `
ignoredfile
`;
        const task = {
            task: 'gitignore',
            actions: [
                {
                    append: 'config2 = use_native_modules!',
                },
            ],
        };
        content = await (0, gitignoreTask_1.gitignoreTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        expect(content).toEqual(`
ignoredfile
config2 = use_native_modules!
`);
    });
    it('should insert text after point with comment', async () => {
        let content = `
ignoredfile
`;
        const task = {
            task: 'gitignore',
            actions: [
                {
                    after: 'config',
                    prepend: 'config2 = use_native_modules!',
                    comment: 'test comment',
                },
            ],
        };
        content = await (0, gitignoreTask_1.gitignoreTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        expect(content).toContain(`
ignoredfile
`);
    });
    it('should skip if condition not met', async () => {
        const content = '';
        const task = {
            task: 'gitignore',
            actions: [
                {
                    when: { test: 'random' },
                    prepend: 'random;',
                },
            ],
        };
        await expect((0, gitignoreTask_1.gitignoreTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        })).resolves.not.toThrowError('target not found');
    });
    describe('runTask', () => {
        it('should read and write gitignore file', async () => {
            let content = `
test1;
test3;
`;
            const gitignorePath = path_1.default.resolve(__dirname, `../../mock-project/${constants_1.Constants.GITIGNORE_FILE_NAME}`);
            mockFs.writeFileSync(gitignorePath, content);
            const task = {
                task: 'gitignore',
                actions: [
                    {
                        prepend: 'test2;',
                    },
                ],
            };
            await (0, gitignoreTask_1.runTask)({
                configPath: 'path/to/config',
                task: task,
                packageName: 'test-package',
            });
            content = mockFs.readFileSync(gitignorePath);
            // @ts-ignore
            expect(content).toContain(task.actions[0].prepend);
        });
        it('should throw when insertion point not found with strict', async () => {
            const content = `
test1;
test3;
`;
            const taskInsertBefore = {
                task: 'gitignore',
                actions: [
                    {
                        before: 'random',
                        append: 'test2;',
                        strict: true,
                    },
                ],
            };
            const taskInsertBeforeNonStrict = {
                task: 'gitignore',
                actions: [
                    {
                        before: 'random',
                        append: 'test2;',
                    },
                ],
            };
            await expect((0, gitignoreTask_1.gitignoreTask)({
                configPath: 'path/to/config',
                task: taskInsertBefore,
                content,
                packageName: 'test-package',
            })).rejects.toThrowError('insertion point');
            await expect((0, gitignoreTask_1.gitignoreTask)({
                configPath: 'path/to/config',
                task: taskInsertBeforeNonStrict,
                content,
                packageName: 'test-package',
            })).resolves.not.toThrowError('insertion point');
            const taskInsertAfter = {
                task: 'gitignore',
                actions: [
                    {
                        after: 'random',
                        prepend: 'test2;',
                        strict: true,
                    },
                ],
            };
            const taskInsertAfterNonStrict = {
                task: 'gitignore',
                actions: [
                    {
                        after: 'random',
                        prepend: 'test2;',
                    },
                ],
            };
            await expect((0, gitignoreTask_1.gitignoreTask)({
                configPath: 'path/to/config',
                task: taskInsertAfter,
                content,
                packageName: 'test-package',
            })).rejects.toThrowError('insertion point');
            await expect((0, gitignoreTask_1.gitignoreTask)({
                configPath: 'path/to/config',
                task: taskInsertAfterNonStrict,
                content,
                packageName: 'test-package',
            })).resolves.not.toThrowError('insertion point');
        });
        it('should throw when block is used', async () => {
            const content = `
test1;
test3;
`;
            const taskInsertBefore = {
                task: 'gitignore',
                actions: [
                    {
                        block: 'test',
                        before: 'random',
                        append: 'test2;',
                        strict: true,
                    },
                ],
            };
            await expect((0, gitignoreTask_1.gitignoreTask)({
                configPath: 'path/to/config',
                task: taskInsertBefore,
                content,
                packageName: 'test-package',
            })).rejects.toThrowError('block is not supported');
        });
        it('should work when gitignore does not exist', async () => {
            const task = {
                task: 'gitignore',
                actions: [
                    {
                        prepend: 'test2;',
                    },
                ],
            };
            await expect((0, gitignoreTask_1.runTask)({
                configPath: 'path/to/config',
                task: task,
                packageName: 'test-package',
            })).resolves.toBeUndefined();
        });
    });
});
