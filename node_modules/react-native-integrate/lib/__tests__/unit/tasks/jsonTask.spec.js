"use strict";
/* eslint-disable @typescript-eslint/no-unsafe-call */
Object.defineProperty(exports, "__esModule", { value: true });
const { mockFs } = require('../../mocks/mockAll');
const mockObjectEntries = jest.spyOn(Object, 'entries');
const jsonTask_1 = require("../../../tasks/jsonTask");
const mockAll_1 = require("../../mocks/mockAll");
describe('jsonTask', () => {
    it('should set value', () => {
        // noinspection SpellCheckingInspection
        let content = {
            test: 'value',
        };
        const task = {
            task: 'json',
            path: 'test.json',
            actions: [
                {
                    set: {
                        test2: 'value2',
                    },
                },
            ],
        };
        content = (0, jsonTask_1.jsonTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        expect(content.test2).toEqual('value2');
    });
    it('should assign value', () => {
        let content = {
            first: {
                second: {
                    third: 'test',
                },
            },
        };
        const task = {
            task: 'json',
            path: 'test.json',
            actions: [
                {
                    set: {
                        first: {
                            assigned: 'test2',
                        },
                    },
                    strategy: 'assign',
                },
            ],
        };
        content = (0, jsonTask_1.jsonTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        expect(content.first).toEqual({
            assigned: 'test2',
        });
    });
    it('should append value if not exists', () => {
        let content = {
            first: {
                second: {
                    third: 'test',
                },
            },
        };
        const task = {
            task: 'json',
            path: 'test.json',
            actions: [
                {
                    set: {
                        first: {
                            assigned: 'test2',
                        },
                        forth: {
                            foo: 'bar',
                        },
                    },
                    strategy: 'append',
                },
            ],
        };
        content = (0, jsonTask_1.jsonTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        expect(content.first).toEqual({
            second: {
                third: 'test',
            },
        });
        expect(content.forth).toEqual({
            foo: 'bar',
        });
    });
    it('should merge value', () => {
        let content = {
            first: {
                second: {
                    third: 'test',
                },
                other: ['test'],
            },
        };
        const task = {
            task: 'json',
            path: 'test.json',
            actions: [
                {
                    set: {
                        first: {
                            assigned: 'test2',
                            other: ['test2'],
                        },
                    },
                    strategy: 'merge',
                },
            ],
        };
        content = (0, jsonTask_1.jsonTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        expect(content.first).toEqual({
            second: {
                third: 'test',
            },
            assigned: 'test2',
            other: ['test2'],
        });
    });
    it('should merge and concat value', () => {
        let content = {
            first: {
                second: {
                    third: 'test',
                },
                other: ['test'],
            },
        };
        const task = {
            task: 'json',
            path: 'test.json',
            actions: [
                {
                    set: {
                        first: {
                            assigned: 'test2',
                            other: ['test', 'test2'],
                        },
                    },
                    strategy: 'merge_concat',
                },
            ],
        };
        content = (0, jsonTask_1.jsonTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        expect(content.first).toEqual({
            second: {
                third: 'test',
            },
            assigned: 'test2',
            other: ['test', 'test', 'test2'],
        });
    });
    it('should merge distinct values', () => {
        let content = {
            first: {
                second: {
                    third: 'test',
                },
                other: [{ test: 1 }],
            },
        };
        const task = {
            task: 'json',
            path: 'test.json',
            actions: [
                {
                    set: {
                        first: {
                            assigned: 'test2',
                            other: [{ test: 1 }, { test2: 1 }],
                        },
                    },
                    strategy: 'merge_distinct',
                },
            ],
        };
        content = (0, jsonTask_1.jsonTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        expect(content.first).toEqual({
            second: {
                third: 'test',
            },
            assigned: 'test2',
            other: [{ test: 1 }, { test2: 1 }],
        });
    });
    it('should assign inner value', () => {
        let content = {
            first: {
                second: {
                    third: 'test',
                },
            },
        };
        const task = {
            task: 'json',
            path: 'test.json',
            actions: [
                {
                    set: {
                        first: {
                            second: {
                                assigned: 'test2',
                                other: ['test2'],
                                $assign: true,
                            },
                        },
                    },
                    strategy: 'merge_concat',
                },
            ],
        };
        content = (0, jsonTask_1.jsonTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        expect(content.first.second).toEqual({
            assigned: 'test2',
            other: ['test2'],
        });
    });
    it('should append inner value if it is new', () => {
        let content = {
            first: {
                second: {
                    third: 'test',
                },
            },
        };
        const task = {
            task: 'json',
            path: 'test.json',
            actions: [
                {
                    set: {
                        first: {
                            second: {
                                assigned: 'test2',
                                $append: true,
                            },
                        },
                    },
                    strategy: 'merge_concat',
                },
            ],
        };
        content = (0, jsonTask_1.jsonTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        expect(content.first.second).toEqual({
            third: 'test',
        });
    });
    it('should set index value', () => {
        let content = {
            first: {
                second: [{ third: 'test' }, { forth: 'test2' }],
            },
        };
        const task = {
            task: 'json',
            path: 'test.json',
            actions: [
                {
                    set: {
                        first: {
                            second: {
                                $index: 0,
                                assigned: 'test2',
                            },
                        },
                    },
                    strategy: 'merge_concat',
                },
            ],
        };
        content = (0, jsonTask_1.jsonTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        expect(content.first.second).toEqual([
            { third: 'test', assigned: 'test2' },
            { forth: 'test2' },
        ]);
    });
    it('should skip if condition not met', () => {
        let content = {
            first: {
                second: [{ third: 'test' }, { forth: 'test2' }],
            },
        };
        const task = {
            task: 'json',
            path: 'test.json',
            actions: [
                {
                    when: { test: 'random' },
                    set: {
                        first: {
                            second: {
                                $index: 0,
                                assigned: 'test2',
                            },
                        },
                    },
                    strategy: 'merge_concat',
                },
            ],
        };
        content = (0, jsonTask_1.jsonTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        expect(content.first.second).not.toEqual([
            { third: 'test', assigned: 'test2' },
            { forth: 'test2' },
        ]);
    });
    it('should throw on random error', () => {
        mockObjectEntries.mockImplementationOnce(() => {
            throw new Error('some random error');
        });
        const content = {
            first: {
                second: [{ third: 'test' }, { forth: 'test2' }],
            },
        };
        const task = {
            task: 'json',
            path: 'test.json',
            actions: [
                {
                    set: {
                        first: {
                            second: {
                                $index: 0,
                                assigned: 'test2',
                            },
                        },
                    },
                    strategy: 'merge_concat',
                },
            ],
        };
        expect(() => (0, jsonTask_1.jsonTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        })).toThrowError('random error');
        jest.unmock('lodash.mergewith');
    });
    describe('runTask', () => {
        it('should read and write json file', () => {
            const jsonPath = (0, mockAll_1.writeMockJson)();
            const task = {
                task: 'json',
                path: 'test.json',
                actions: [
                    {
                        set: {
                            test2: 'value2',
                        },
                    },
                ],
            };
            (0, jsonTask_1.runTask)({
                configPath: 'path/to/config',
                task: task,
                packageName: 'test-package',
            });
            const content = mockFs.readFileSync(jsonPath);
            expect(content).toContain('test2');
        });
        it('should read and write json file of custom target', () => {
            const jsonPath = (0, mockAll_1.writeMockJson)('custom.json');
            const task = {
                task: 'json',
                path: 'custom.json',
                actions: [
                    {
                        set: {
                            test2: 'value2',
                        },
                    },
                ],
            };
            (0, jsonTask_1.runTask)({
                configPath: 'path/to/config',
                task: task,
                packageName: 'test-package',
            });
            const content = mockFs.readFileSync(jsonPath);
            expect(content).toContain('test2');
        });
        it('should not throw when json does not exist', () => {
            const task = {
                task: 'json',
                path: 'test.json',
                actions: [
                    {
                        set: {
                            CFBundleDisplayName: 'test2',
                        },
                    },
                ],
            };
            expect(() => {
                (0, jsonTask_1.runTask)({
                    configPath: 'path/to/config',
                    task: task,
                    packageName: 'test-package',
                });
            }).not.toThrow();
        });
        it('should throw when path is out of project', () => {
            const task = {
                task: 'json',
                path: '../somewhere/test.json',
                actions: [
                    {
                        set: {
                            CFBundleDisplayName: 'test2',
                        },
                    },
                ],
            };
            expect(() => {
                (0, jsonTask_1.runTask)({
                    configPath: 'path/to/config',
                    task: task,
                    packageName: 'test-package',
                });
            }).toThrowError('invalid destination path');
        });
    });
});
