"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require('../../mocks/mockAll');
const mockSpawn = jest.spyOn(require('child_process'), 'spawn');
const shellTask_1 = require("../../../tasks/shellTask");
const variables_1 = require("../../../variables");
const mockPrompter_1 = require("../../mocks/mockPrompter");
describe('shellTask', () => {
    it('should run command', async () => {
        mockSpawn.mockImplementationOnce(() => ({
            on: (_event, cb) => {
                cb(0);
            },
            stdout: {
                on: (_event, cb) => {
                    cb('stdout');
                },
            },
            stderr: {
                on: (_event, cb) => {
                    cb('stderr');
                },
            },
        }));
        const task = {
            task: 'shell',
            actions: [
                {
                    name: 'test',
                    command: 'test',
                    cwd: 'test',
                },
            ],
        };
        await (0, shellTask_1.shellTask)({
            configPath: 'path/to/config',
            task: task,
            packageName: 'test-package',
        });
        expect(mockSpawn).toHaveBeenCalled();
        expect(variables_1.variables.get('test.output')).toBe('stdoutstderr');
        mockSpawn.mockReset();
    });
    it('should run command with args', async () => {
        mockSpawn.mockImplementationOnce(() => ({
            on: (_event, cb) => {
                cb(0);
            },
            stdout: {
                on: (_event, cb) => {
                    cb('stdout');
                },
            },
            stderr: {
                on: (_event, cb) => {
                    cb('stderr');
                },
            },
        }));
        const task = {
            task: 'shell',
            actions: [
                {
                    name: 'test',
                    command: 'test',
                    args: ['arg1', 'arg2 arg3'],
                },
            ],
        };
        await (0, shellTask_1.shellTask)({
            configPath: 'path/to/config',
            task: task,
            packageName: 'test-package',
        });
        expect(mockSpawn).toHaveBeenCalledWith('test', ['arg1', 'arg2 arg3'], expect.anything());
        mockSpawn.mockReset();
    });
    it('should handle unexpected error', async () => {
        mockSpawn.mockImplementationOnce(() => {
            throw new Error('unexpected error');
        });
        const task = {
            task: 'shell',
            actions: [
                {
                    name: 'test',
                    command: 'test',
                },
            ],
        };
        await expect((0, shellTask_1.shellTask)({
            configPath: 'path/to/config',
            task: task,
            packageName: 'test-package',
        })).rejects.toThrowError('unexpected error');
        expect(variables_1.variables.get('test')).toEqual('error');
        mockSpawn.mockReset();
    });
    it('should handle invalid cwd', async () => {
        mockSpawn.mockImplementationOnce(() => {
            throw new Error('unexpected error');
        });
        const task = {
            task: 'shell',
            actions: [
                {
                    name: 'test',
                    command: 'test',
                    cwd: '../../',
                },
            ],
        };
        await expect((0, shellTask_1.shellTask)({
            configPath: 'path/to/config',
            task: task,
            packageName: 'test-package',
        })).rejects.toThrowError('invalid cwd path');
        expect(variables_1.variables.get('test')).toEqual('error');
        mockSpawn.mockReset();
    });
    it('should handle non zero exit code', async () => {
        mockSpawn.mockImplementationOnce(() => ({
            on: (_event, cb) => {
                cb(1);
            },
            stdout: {
                on: (_event, cb) => {
                    cb('stdout');
                },
            },
            stderr: {
                on: (_event, cb) => {
                    cb('stderr');
                },
            },
        }));
        const task = {
            task: 'shell',
            actions: [
                {
                    name: 'test',
                    command: 'test',
                },
            ],
        };
        await expect((0, shellTask_1.shellTask)({
            configPath: 'path/to/config',
            task: task,
            packageName: 'test-package',
        })).rejects.toThrowError('non zero exit code');
        expect(variables_1.variables.get('test')).toEqual('error');
        mockSpawn.mockReset();
    });
    it('should skip when condition does not meet', async () => {
        const task = {
            task: 'shell',
            actions: [
                {
                    when: { random: false },
                    name: 'test',
                    command: 'test',
                },
            ],
        };
        await (0, shellTask_1.shellTask)({
            configPath: 'path/to/config',
            task: task,
            packageName: 'test-package',
        });
        expect(mockSpawn).not.toHaveBeenCalled();
        mockSpawn.mockReset();
    });
    it('should skip when execution not allowed', async () => {
        mockPrompter_1.mockPrompter.confirm.mockClear();
        mockPrompter_1.mockPrompter.confirm.mockReturnValueOnce(false);
        const task = {
            task: 'shell',
            actions: [
                {
                    name: 'test',
                    command: 'test',
                },
            ],
        };
        await (0, shellTask_1.shellTask)({
            configPath: 'path/to/config',
            task: task,
            packageName: 'test-package',
        });
        expect(mockSpawn).not.toHaveBeenCalled();
        mockSpawn.mockReset();
        mockPrompter_1.mockPrompter.confirm.mockReset();
    });
});
