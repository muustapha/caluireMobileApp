"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const prettier = require('prettier');
const mockPrettierResolve = jest.spyOn(prettier, 'resolveConfig');
const mockPrettierFormat = jest.spyOn(prettier, 'format');
require('../../mocks/mockAll');
const path_1 = __importDefault(require("path"));
const constants_1 = require("../../../constants");
const babelConfigTask_1 = require("../../../tasks/babelConfigTask");
const getProjectPath_1 = require("../../../utils/getProjectPath");
const mockFs_1 = require("../../mocks/mockFs");
describe('babelConfigTask', () => {
    it('should modify blocks correctly', async () => {
        let content = `module.exports = {
  presets: ['item1', ['item2'], {'item3'}],
};
`;
        const task = {
            task: 'babel_config',
            actions: [
                {
                    block: 'presets',
                    prepend: 'item0',
                },
                {
                    block: 'presets',
                    append: 'item4',
                },
                {
                    block: 'presets',
                    search: 'item2',
                    replace: 'item21',
                },
            ],
        };
        content = await (0, babelConfigTask_1.babelConfigTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        expect(content).toMatchInlineSnapshot(`
      "module.exports = {
        presets: ['item0', 'item1', 'item21', {'item3'}, 'item4'],
      };
      "
    `);
    });
    it('should skip when condition not met', async () => {
        const content = `module.exports = {
  presets: ['item1', ['item2'], {'item3'}],
};
`;
        const task = {
            task: 'babel_config',
            actions: [
                {
                    when: { random: 'value' },
                    block: 'presets',
                    prepend: 'item0',
                },
            ],
        };
        const newContent = await (0, babelConfigTask_1.babelConfigTask)({
            configPath: 'path/to/config',
            task: task,
            content,
            packageName: 'test-package',
        });
        expect(newContent).toEqual(content);
    });
    it('should throw when insertion point not found with strict', async () => {
        const content = `module.exports = {
  presets: ['item1', ['item2'], {'item3'}],
};
`;
        for (const criteria of ['before', 'after', 'search']) {
            const task = {
                task: 'babel_config',
                actions: [
                    {
                        block: 'presets',
                        [criteria]: 'item0',
                        strict: true,
                    },
                ],
            };
            await expect((0, babelConfigTask_1.babelConfigTask)({
                configPath: 'path/to/config',
                task: task,
                content,
                packageName: 'test-package',
            })).rejects.toThrowError('insertion point');
        }
    });
    describe('getReducedContext', () => {
        const array = ['item1', 'item2', 'item3'];
        it('should return correctly with before', () => {
            const result = (0, babelConfigTask_1.getReducedContext)(array, {
                before: 'item2',
            });
            expect(result).toMatchInlineSnapshot(`
        Array [
          0,
          1,
        ]
      `);
        });
        it('should return correctly with after', () => {
            const result = (0, babelConfigTask_1.getReducedContext)(array, {
                after: 'item2',
            });
            expect(result).toMatchInlineSnapshot(`
        Array [
          2,
          3,
        ]
      `);
        });
        it('should return correctly with search', () => {
            const result = (0, babelConfigTask_1.getReducedContext)(array, {
                search: 'item2',
            });
            expect(result).toMatchInlineSnapshot(`
        Array [
          1,
          2,
        ]
      `);
        });
        it('should ignore when criterias not found', () => {
            const result = (0, babelConfigTask_1.getReducedContext)(array, {
                before: 'random',
                after: 'random',
                search: 'random',
            });
            expect(result).toMatchInlineSnapshot(`
        Array [
          0,
          3,
        ]
      `);
        });
        it('should throw with strict', () => {
            expect(() => (0, babelConfigTask_1.getReducedContext)(array, {
                search: 'random',
                strict: true,
            })).toThrowError('insertion point');
        });
    });
    describe('shouldApplyInsertion', () => {
        const array = ['item1', 'item2', 'item3'];
        it('should return true', () => {
            const result = (0, babelConfigTask_1.shouldApplyInsertion)(array, {
                name: 'some name',
            }, '4');
            expect(result).toBeTruthy();
        });
        it('should return false when ifNotPresent exists', () => {
            const result = (0, babelConfigTask_1.shouldApplyInsertion)(array, {
                name: 'some name',
                ifNotPresent: 'item3',
            }, 'item4');
            expect(result).toBeFalsy();
        });
        it('should return false when item exists', () => {
            const result = (0, babelConfigTask_1.shouldApplyInsertion)(array, {
                name: 'some name',
            }, 'item3');
            expect(result).toBeFalsy();
        });
    });
    describe('babelParser', () => {
        it('should handle unexpected error', async () => {
            const babelConfig = `module.exports = {
  presets: ['module:metro-react-native-babel-preset'],
};
`;
            const parsed = babelConfigTask_1.babelParser.parse(babelConfig);
            parsed.plugins.push('some plugin');
            parsed.presets.push('some preset');
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call
            let prettierConfig = await prettier.resolveConfig((0, getProjectPath_1.getProjectPath)());
            if (!prettierConfig)
                prettierConfig = {};
            if (!prettierConfig.parser)
                prettierConfig.parser = 'babel';
            expect(
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call
            await prettier.format(babelConfigTask_1.babelParser.stringify(parsed), prettierConfig)).toMatchInlineSnapshot(`
        "module.exports = {
          presets: ['module:metro-react-native-babel-preset', 'some preset'],
          plugins: ['some plugin'],
        };
        "
      `);
        });
        it('should throw with no exports', () => {
            const babelConfig = '';
            const parsed = babelConfigTask_1.babelParser.parse(babelConfig);
            parsed.presets.push('anything');
            expect(() => babelConfigTask_1.babelParser.stringify(parsed)).toThrowError('exports start');
        });
    });
    describe('runTask', () => {
        it('should read and write babel config file', async () => {
            let content = `module.exports = {
  presets: ['item1', 'item2', 'item3'],
};
`;
            const babelConfigPath = path_1.default.resolve(__dirname, `../../mock-project/${constants_1.Constants.BABEL_CONFIG_FILE_NAME}`);
            mockFs_1.mockFs.writeFileSync(babelConfigPath, content);
            const task = {
                task: 'babel_config',
                actions: [
                    {
                        prepend: 'require("somthing")',
                    },
                ],
            };
            await (0, babelConfigTask_1.runTask)({
                configPath: 'path/to/config',
                task: task,
                packageName: 'test-package',
            });
            content = mockFs_1.mockFs.readFileSync(babelConfigPath);
            // @ts-ignore
            expect(content).toMatchInlineSnapshot(`
        "require('somthing');
        module.exports = {
          presets: ['item1', 'item2', 'item3'],
        };
        "
      `);
        });
        it('should run prettier with default parser', async () => {
            const content = `module.exports = {
  presets: ['item1', 'item2', 'item3'],
};
`;
            mockPrettierResolve.mockReturnValueOnce(null);
            const babelConfigPath = path_1.default.resolve(__dirname, `../../mock-project/${constants_1.Constants.BABEL_CONFIG_FILE_NAME}`);
            mockFs_1.mockFs.writeFileSync(babelConfigPath, content);
            const task = {
                task: 'babel_config',
                actions: [
                    {
                        prepend: 'require("somthing")',
                    },
                ],
            };
            await (0, babelConfigTask_1.runTask)({
                configPath: 'path/to/config',
                task: task,
                packageName: 'test-package',
            });
            expect(mockPrettierFormat).toHaveBeenCalledWith(expect.anything(), expect.objectContaining({
                parser: 'babel',
            }));
        });
        it('should throw when babel config does not exist', async () => {
            const task = {
                task: 'babel_config',
                actions: [
                    {
                        block: 'presets',
                        prepend: 'item0;',
                    },
                ],
            };
            await expect((0, babelConfigTask_1.runTask)({
                configPath: 'path/to/config',
                task: task,
                packageName: 'test-package',
            })).rejects.toThrowError('babel.config.js file not found');
        });
    });
});
