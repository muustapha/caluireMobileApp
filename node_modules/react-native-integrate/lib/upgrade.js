"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.upgrade = void 0;
const path_1 = __importDefault(require("path"));
const picocolors_1 = __importDefault(require("picocolors"));
const preload_1 = __importDefault(require("semver/preload"));
const prompter_1 = require("./prompter");
const analyzePackages_1 = require("./utils/analyzePackages");
const getErrMessage_1 = require("./utils/getErrMessage");
const getPackageConfig_1 = require("./utils/getPackageConfig");
const parseConfig_1 = require("./utils/parseConfig");
const runTask_1 = require("./utils/runTask");
const satisfies_1 = require("./utils/satisfies");
const setState_1 = require("./utils/setState");
const taskManager_1 = require("./utils/taskManager");
const topologicalSort_1 = require("./utils/topologicalSort");
const updateIntegrationStatus_1 = require("./utils/updateIntegrationStatus");
const importFromOldProject_1 = require("./utils/upgrade/importFromOldProject");
const runUpgradeTasks_1 = require("./utils/upgrade/runUpgradeTasks");
const restoreBackupFiles_1 = require("./utils/upgrade/restoreBackupFiles");
const validateOldProjectPath_1 = require("./utils/upgrade/validateOldProjectPath");
const variables_1 = require("./variables");
// TODO: remove when we update min supported node and start using fs.rm instead of fs.rmdir
process.removeAllListeners('warning');
async function upgrade() {
    (0, prompter_1.logInfo)(picocolors_1.default.bold(picocolors_1.default.inverse(picocolors_1.default.magenta(' stage 1 '))) +
        picocolors_1.default.bold(picocolors_1.default.magenta(' Import old project data ')));
    // get old project path
    let oldProjectPath = await (0, prompter_1.text)('Enter old project path to import some basic data (display name, icons, etc.)', {
        placeholder: 'leave empty to skip',
        validate: validateOldProjectPath_1.validateOldProjectPath,
    });
    if (oldProjectPath) {
        oldProjectPath = path_1.default.resolve(oldProjectPath);
        const didImport = await (0, importFromOldProject_1.importFromOldProject)(oldProjectPath);
        if (didImport) {
            (0, prompter_1.logSuccess)(picocolors_1.default.inverse(picocolors_1.default.bold(picocolors_1.default.green(' imported '))) +
                picocolors_1.default.green(' imported project data successfully'));
        }
    }
    else {
        (0, prompter_1.logMessageGray)('skipping import from old project');
    }
    (0, prompter_1.logInfo)(picocolors_1.default.bold(picocolors_1.default.inverse(picocolors_1.default.magenta(' stage 2 '))) +
        picocolors_1.default.bold(picocolors_1.default.magenta(' Re-integrate packages ')));
    let skipStage2 = false;
    (0, prompter_1.startSpinner)('analyzing packages');
    const analyzedPackages = (0, analyzePackages_1.analyzePackages)();
    const { installedPackages, integratedPackages } = analyzedPackages;
    variables_1.variables.setPredefined('__UPGRADE__', true);
    if (analyzedPackages.justCreatedLockFile) {
        (0, prompter_1.stopSpinner)(picocolors_1.default.gray(picocolors_1.default.italic('integrate-lock.json not found. Nothing to re-integrate.')));
        skipStage2 = true;
    }
    if (!skipStage2) {
        (0, prompter_1.stopSpinner)(`analyzed ${installedPackages.length} packages`);
        const packageLockUpdates = [];
        let packagesToIntegrate = [];
        (0, prompter_1.startSpinner)('checking package configuration');
        for (let i = 0; i < integratedPackages.length; i++) {
            const [packageName] = integratedPackages[i];
            const installedPackage = installedPackages.find(([installedPackageName]) => installedPackageName === packageName);
            if (!installedPackage) {
                (0, prompter_1.logWarning)(`Skipping integration of ${picocolors_1.default.bold(picocolors_1.default.blue(packageName))} because it is not installed.`);
                continue;
            }
            const version = installedPackage[1];
            const configPath = await (0, getPackageConfig_1.getPackageConfig)(packageName, {
                index: i,
                count: integratedPackages.length,
            });
            if (!configPath) {
                (0, prompter_1.logWarning)(`Skipping integration of ${picocolors_1.default.bold(picocolors_1.default.blue(packageName))} because currently it has no configuration.`);
                continue;
            }
            let config;
            try {
                config = (0, parseConfig_1.parseConfig)(configPath);
            }
            catch (e) {
                (0, prompter_1.logError)(picocolors_1.default.bold(picocolors_1.default.bgRed(' error ')) +
                    picocolors_1.default.bold(picocolors_1.default.blue(` ${packageName} `)) +
                    picocolors_1.default.red('could not parse package configuration\n') +
                    picocolors_1.default.gray((0, getErrMessage_1.getErrMessage)(e, 'validation')), true);
                continue;
            }
            const rnVersionEntry = installedPackages.find(entry => entry[0] === 'react-native');
            if (!rnVersionEntry) {
                (0, prompter_1.stopSpinner)('checked package configuration');
                (0, prompter_1.logWarning)('React Native not installed!?');
                return;
            }
            const rnVersion = rnVersionEntry[1];
            const semRnVersion = preload_1.default.coerce(rnVersion);
            if (!semRnVersion) {
                (0, prompter_1.stopSpinner)('checked package configuration');
                (0, prompter_1.logWarning)(`React Native version (${rnVersion}) is invalid!?`);
                return;
            }
            variables_1.variables.setPredefined('RN_VERSION', {
                major: semRnVersion.major,
                minor: semRnVersion.minor,
                patch: semRnVersion.patch,
            });
            if (config.minRNVersion) {
                if (preload_1.default.lt(semRnVersion, preload_1.default.coerce(config.minRNVersion) || '0.0.0')) {
                    (0, prompter_1.stopSpinner)('checked package configuration');
                    (0, prompter_1.logWarning)(`${picocolors_1.default.bold(picocolors_1.default.blue(packageName))} requires React Native version ${picocolors_1.default.bold(picocolors_1.default.blue(config.minRNVersion))}`);
                    return;
                }
            }
            if (config.minVersion) {
                if (preload_1.default.lt(preload_1.default.coerce(version) || '0.0.0', preload_1.default.coerce(config.minVersion) || '0.0.0')) {
                    (0, prompter_1.stopSpinner)('checked package configuration');
                    (0, prompter_1.logWarning)(`${picocolors_1.default.bold(picocolors_1.default.blue(packageName))} requires version ${picocolors_1.default.bold(picocolors_1.default.blue(config.minVersion))} - please update it first and try again`);
                    return;
                }
            }
            if (config.dependencies?.length) {
                for (const dependentPackageName of config.dependencies) {
                    // check if dependency is not integrated
                    const isNotIntegrated = integratedPackages.every(([packageName]) => packageName != dependentPackageName);
                    if (isNotIntegrated) {
                        (0, prompter_1.stopSpinner)('checked package configuration');
                        (0, prompter_1.logWarning)(`Skipping integration of ${picocolors_1.default.bold(picocolors_1.default.blue(packageName))} because the dependant package ${picocolors_1.default.bold(picocolors_1.default.blue(dependentPackageName))} is not integrated.`);
                        return;
                    }
                }
            }
            packagesToIntegrate.push({
                packageName,
                version,
                configPath,
                config,
            });
        }
        let msg = 'checked package configuration';
        if (packagesToIntegrate.length > 0) {
            msg += picocolors_1.default.green(` | ${packagesToIntegrate.length} package will be re-integrated`);
        }
        else {
            msg += ' | no packages to integrate';
        }
        (0, prompter_1.stopSpinner)(msg);
        if (packagesToIntegrate.length) {
            packagesToIntegrate = (0, topologicalSort_1.topologicalSort)(packagesToIntegrate);
            for (let i = 0; i < packagesToIntegrate.length; i++) {
                const { packageName, version, configPath, config } = packagesToIntegrate[i];
                (0, prompter_1.logInfo)(picocolors_1.default.bold(picocolors_1.default.bgBlue(' package ')) +
                    picocolors_1.default.bold(picocolors_1.default.blue(` ${packageName} `)));
                variables_1.variables.clear(); // reset variables
                if (config.env) {
                    Object.entries(config.env).forEach(([name, value]) => variables_1.variables.set(name, (0, variables_1.transformTextInObject)(value)));
                }
                let failedTaskCount = 0, completedTaskCount = 0;
                for (const task of config.steps) {
                    if (task.when &&
                        !(0, satisfies_1.satisfies)(variables_1.variables.getStore(), (0, variables_1.transformTextInObject)(task.when))) {
                        (0, setState_1.setState)(task.name, {
                            state: 'skipped',
                            error: false,
                        });
                        continue;
                    }
                    (0, setState_1.setState)(task.name, {
                        state: 'progress',
                        error: false,
                    });
                    const isNonSystemTask = !taskManager_1.taskManager.isSystemTask(task.task);
                    if (isNonSystemTask) {
                        if (task.label)
                            task.label = (0, variables_1.getText)(task.label);
                        else
                            task.label = taskManager_1.taskManager.task[task.task].summary;
                        (0, prompter_1.logInfo)(picocolors_1.default.bold(picocolors_1.default.inverse(picocolors_1.default.cyan(' task '))) +
                            picocolors_1.default.bold(picocolors_1.default.cyan(` ${task.label} `)));
                    }
                    try {
                        await (0, runTask_1.runTask)({
                            configPath,
                            packageName,
                            task,
                        });
                        completedTaskCount++;
                        (0, setState_1.setState)(task.name, {
                            state: 'done',
                            error: false,
                        });
                    }
                    catch (e) {
                        failedTaskCount++;
                        const errMessage = (0, getErrMessage_1.getErrMessage)(e);
                        (0, prompter_1.logError)(errMessage);
                        (0, setState_1.setState)(task.name, {
                            state: 'error',
                            reason: errMessage,
                            error: true,
                        });
                    }
                }
                if (failedTaskCount) {
                    (0, prompter_1.logWarning)(picocolors_1.default.inverse(picocolors_1.default.bold(picocolors_1.default.yellow(' re-integrated with errors '))) +
                        picocolors_1.default.bold(picocolors_1.default.blue(` ${packageName} `)) +
                        picocolors_1.default.yellow(`failed to complete ${failedTaskCount} task(s) - please complete this integration manually`), true);
                }
                else {
                    (0, prompter_1.logSuccess)(picocolors_1.default.inverse(picocolors_1.default.bold(picocolors_1.default.green(' re-integrated '))) +
                        picocolors_1.default.black(picocolors_1.default.bold(picocolors_1.default.blue(` ${packageName} `))) +
                        picocolors_1.default.green(`completed ${completedTaskCount} task(s) successfully`));
                }
                packageLockUpdates.push({
                    packageName,
                    lockProjectData: {
                        version,
                        integrated: true,
                    },
                });
            }
        }
        (0, updateIntegrationStatus_1.updateIntegrationStatus)(packageLockUpdates);
    }
    (0, prompter_1.logInfo)(picocolors_1.default.bold(picocolors_1.default.inverse(picocolors_1.default.magenta(' stage 3 '))) +
        picocolors_1.default.bold(picocolors_1.default.magenta(' Import files from .upgrade/imports ')));
    const didRestore = await (0, restoreBackupFiles_1.restoreBackupFiles)().catch((e) => {
        (0, prompter_1.logWarning)(e.message);
    });
    if (didRestore) {
        (0, prompter_1.logSuccess)(picocolors_1.default.inverse(picocolors_1.default.bold(picocolors_1.default.green(' imported '))) +
            picocolors_1.default.green(' files were imported successfully'));
    }
    (0, prompter_1.logInfo)(picocolors_1.default.bold(picocolors_1.default.inverse(picocolors_1.default.magenta(' stage 4 '))) +
        picocolors_1.default.bold(picocolors_1.default.magenta(' Execute upgrade.yml steps ')));
    const upgradeResult = await (0, runUpgradeTasks_1.runUpgradeTasks)(oldProjectPath).catch((e) => {
        (0, prompter_1.logWarning)(e.message);
    });
    if (upgradeResult && upgradeResult.didRun) {
        if (upgradeResult.failedTaskCount) {
            (0, prompter_1.logWarning)(picocolors_1.default.inverse(picocolors_1.default.bold(picocolors_1.default.yellow(' executed with errors '))) +
                picocolors_1.default.bold(picocolors_1.default.blue(' upgrade.yml ')) +
                picocolors_1.default.yellow(`failed to complete ${upgradeResult.failedTaskCount} task(s) - please complete upgrade manually`), true);
        }
        else {
            (0, prompter_1.logSuccess)(picocolors_1.default.inverse(picocolors_1.default.bold(picocolors_1.default.green(' executed '))) +
                picocolors_1.default.black(picocolors_1.default.bold(picocolors_1.default.blue(' upgrade.yml '))) +
                picocolors_1.default.green(`completed ${upgradeResult.completedTaskCount} task(s) successfully`));
        }
    }
}
exports.upgrade = upgrade;
