"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInfo = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const picocolors_1 = __importDefault(require("picocolors"));
const constants_1 = require("./constants");
const prompter_1 = require("./prompter");
const getInstalledPackages_1 = require("./utils/getInstalledPackages");
const getPackageConfig_1 = require("./utils/getPackageConfig");
const getProjectPath_1 = require("./utils/getProjectPath");
const parseConfig_1 = require("./utils/parseConfig");
const taskManager_1 = require("./utils/taskManager");
async function getInfo(packageName) {
    (0, prompter_1.logInfo)(picocolors_1.default.bold(picocolors_1.default.bgBlue(' package ')) +
        picocolors_1.default.bold(picocolors_1.default.blue(` ${packageName} `)));
    const packageJsonPathExists = fs_1.default.existsSync((0, getInstalledPackages_1.getPackageJsonPath)());
    let localPathExists = false, localConfigPath;
    if (packageJsonPathExists) {
        const installedPackages = (0, getInstalledPackages_1.getInstalledPackages)();
        const isInstalled = installedPackages.some(([installedPackageName]) => installedPackageName == packageName);
        (0, prompter_1.log)(`package installation: ${isInstalled
            ? picocolors_1.default.bold(picocolors_1.default.green('exists'))
            : picocolors_1.default.gray('not found')}\n${picocolors_1.default.dim('in package.json')}`);
        localConfigPath = path_1.default.join((0, getPackageConfig_1.getPackagePath)(packageName), constants_1.Constants.CONFIG_FILE_NAME);
        localPathExists = fs_1.default.existsSync(localConfigPath);
        (0, prompter_1.log)(`local configuration: ${localPathExists
            ? picocolors_1.default.bold(picocolors_1.default.green('exists'))
            : picocolors_1.default.gray('not found')}\n` + picocolors_1.default.dim('at ' + localConfigPath.replace((0, getProjectPath_1.getProjectPath)(), '.')));
    }
    const remotePath = (0, getPackageConfig_1.getRemotePath)(packageName, constants_1.Constants.REMOTE_CONFIG_REPO_HOME);
    (0, prompter_1.startSpinner)('checking remote configuration file');
    const remoteFileContent = await (0, getPackageConfig_1.getRemoteFile)((0, getPackageConfig_1.getRemotePath)(packageName));
    (0, prompter_1.stopSpinner)((`remote configuration: ${remoteFileContent
        ? picocolors_1.default.bold(picocolors_1.default.green('exists'))
        : picocolors_1.default.gray('not found')}\n` + picocolors_1.default.dim('at ' + remotePath)).replace(/\n/g, `\n${picocolors_1.default.gray('â”‚ ')} `));
    let config;
    if (localPathExists && localConfigPath) {
        config = (0, parseConfig_1.parseConfig)(localConfigPath);
    }
    else if (remoteFileContent)
        config = (0, parseConfig_1.parseConfigString)(remoteFileContent, 'integrate');
    if (config) {
        const _config = config;
        (0, prompter_1.logSuccess)(picocolors_1.default.inverse(picocolors_1.default.bold(picocolors_1.default.green(' exists '))) +
            picocolors_1.default.black(picocolors_1.default.bold(picocolors_1.default.blue(` ${packageName} `))) +
            picocolors_1.default.green('is ready and available for integration'));
        (0, prompter_1.log)('steps: ' +
            picocolors_1.default.yellow(taskManager_1.taskManager.getNonSystemTasks(_config.steps).length) +
            '\n' +
            Object.entries(taskManager_1.taskManager.task)
                .map(([taskType, value]) => {
                if (taskManager_1.taskManager.isSystemTask(taskType))
                    return null;
                const configTasks = _config.steps.filter(x => x.task == taskType);
                if (!configTasks.length)
                    return null;
                let summary = value.summary;
                const actionCount = configTasks.reduce((n, o) => {
                    if ('actions' in o)
                        n += o.actions.length;
                    return n;
                }, 0);
                if (actionCount)
                    summary += ` | ${actionCount} action(s)`;
                return picocolors_1.default.yellow(summary);
            })
                .filter(x => x)
                .join('\n'));
        if (packageJsonPathExists) {
            (0, prompter_1.logNote)(`npx react-native-integrate ${packageName}`, 'run command to integrate');
        }
    }
    else {
        (0, prompter_1.logWarning)(picocolors_1.default.inverse(picocolors_1.default.bold(picocolors_1.default.yellow(' not found '))) +
            picocolors_1.default.bold(picocolors_1.default.blue(` ${packageName} `)) +
            picocolors_1.default.yellow('is not available for integration'), true);
    }
}
exports.getInfo = getInfo;
