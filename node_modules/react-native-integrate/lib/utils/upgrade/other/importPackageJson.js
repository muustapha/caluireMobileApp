"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInstallCommand = exports.importPackageJson = void 0;
const child_process_1 = require("child_process");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const picocolors_1 = __importDefault(require("picocolors"));
const prompter_1 = require("../../../prompter");
const applyObjectModification_1 = require("../../applyObjectModification");
const getInstalledPackages_1 = require("../../getInstalledPackages");
function importPackageJson(projectPath) {
    try {
        const packageJson = (0, getInstalledPackages_1.getPackageJson)(projectPath);
        // check if it is rn project
        if (!packageJson.dependencies ||
            !('react-native' in packageJson.dependencies))
            return null;
        return {
            id: 'packageJson',
            title: 'Package.json',
            value: `${packageJson.name}@${packageJson.version}`,
            apply: () => setPackageJson(projectPath, packageJson),
        };
    }
    catch (e) {
        return null;
    }
}
exports.importPackageJson = importPackageJson;
async function setPackageJson(oldProjectPath, oldPackageJson) {
    const packageJson = (0, getInstalledPackages_1.getPackageJson)();
    // process rest
    Object.entries(oldPackageJson).forEach(([key, value]) => {
        switch (key) {
            case 'dependencies':
                // append new dependencies only
                packageJson.dependencies = (0, applyObjectModification_1.modifyObject)(packageJson.dependencies, value, 'append');
                // sort dependencies
                packageJson.dependencies = Object.fromEntries(Object.entries(packageJson.dependencies).sort());
                break;
            case 'devDependencies':
                // append new dev dependencies only
                packageJson.devDependencies = (0, applyObjectModification_1.modifyObject)(packageJson.devDependencies || {}, value, 'append');
                // sort devDependencies
                packageJson.devDependencies = Object.fromEntries(Object.entries(packageJson.devDependencies).sort());
                break;
            case 'version':
            case 'description':
                // import version and description
                packageJson[key] = value;
                break;
            default:
                if (typeof value === 'string') {
                    // import any old string which doesn't exist in new
                    if (!(key in packageJson))
                        packageJson[key] = value;
                }
                else if (typeof value === 'object') {
                    if (packageJson[key] == null) {
                        // import any old object which doesn't exist in new
                        packageJson[key] = value;
                    }
                    else if (typeof packageJson[key] === 'object') {
                        // merge old object with append mode
                        packageJson[key] = (0, applyObjectModification_1.modifyObject)(packageJson[key], value, 'append');
                    }
                }
                break;
        }
    });
    const packageJsonPath = (0, getInstalledPackages_1.getPackageJsonPath)();
    fs_1.default.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2), 'utf-8');
    (0, prompter_1.logMessage)(`merged ${picocolors_1.default.yellow('package.json')}`);
    const installCommand = await getInstallCommand(oldProjectPath);
    (0, prompter_1.startSpinner)(`installing modules using ${picocolors_1.default.yellow(installCommand)} ${picocolors_1.default.gray('(this may take a while)')}`);
    const exitCode = await new Promise(resolve => {
        const parts = installCommand.split(' ');
        const command = parts[0] + (process.platform == 'win32' ? '.cmd' : '');
        const child = (0, child_process_1.spawn)(command, parts.slice(1));
        // child.stdout.pipe(process.stdout);
        // child.stderr.pipe(process.stderr);
        child.on('close', code => {
            resolve(code);
        });
    });
    if (exitCode !== 0) {
        (0, prompter_1.stopSpinner)(`${picocolors_1.default.red(`installation using ${picocolors_1.default.yellow(installCommand)} ended with exit code `)}${picocolors_1.default.yellow(exitCode?.toString())}`);
        await (0, prompter_1.multiselect)('Please complete installation manually and return here to proceed.', {
            options: [
                { label: 'completed installation, continue upgrade', value: true },
            ],
            required: true,
        });
    }
    else {
        (0, prompter_1.stopSpinner)('installed modules');
    }
}
async function getInstallCommand(projectPath) {
    const isNpmLockPresent = fs_1.default.existsSync(path_1.default.join(projectPath, 'package-lock.json'));
    const isYarnLockPresent = fs_1.default.existsSync(path_1.default.join(projectPath, 'yarn.lock'));
    const isPnpmLockPresent = fs_1.default.existsSync(path_1.default.join(projectPath, 'pnpm-lock.yaml'));
    const isBunLockPresent = fs_1.default.existsSync(path_1.default.join(projectPath, 'bun.lockb'));
    const options = [];
    if (isNpmLockPresent)
        options.push({ label: 'npm', value: 'npm install' });
    if (isYarnLockPresent)
        options.push({ label: 'yarn', value: 'yarn install' });
    if (isPnpmLockPresent)
        options.push({ label: 'pnpm', value: 'pnpm install' });
    if (isBunLockPresent)
        options.push({ label: 'bun', value: 'bun install' });
    let installer;
    if (options.length > 1) {
        installer = (await (0, prompter_1.select)('Multiple lock files found, please select an installer:', {
            options,
        }));
    }
    else if (options.length === 1) {
        installer = options[0].value;
    }
    else {
        installer = 'npm install';
    }
    return installer;
}
exports.getInstallCommand = getInstallCommand;
