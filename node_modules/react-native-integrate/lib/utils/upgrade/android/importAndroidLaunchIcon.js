"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.importAndroidLaunchIcon = void 0;
const fs_1 = __importDefault(require("fs"));
const glob_1 = require("glob");
const path_1 = __importDefault(require("path"));
const picocolors_1 = __importDefault(require("picocolors"));
const prompter_1 = require("../../../prompter");
const getProjectPath_1 = require("../../getProjectPath");
function importAndroidLaunchIcon(projectPath) {
    try {
        const mipmaps = (0, glob_1.globSync)([projectPath, 'android/app/src/main/res/mipmap-*/*'].join('/'), { nodir: true });
        // get launcher icon and launcher round icon name from AndroidManifest.xml
        const manifestPath = path_1.default.join(projectPath, 'android/app/src/main/AndroidManifest.xml');
        const manifest = fs_1.default.readFileSync(manifestPath, 'utf8');
        const iconMatch = manifest.match(/android:icon="(.*)"/);
        const icon = iconMatch?.[1];
        const roundIconMatch = manifest.match(/android:roundIcon="(.*)"/);
        const roundIcon = roundIconMatch?.[1];
        if (!icon)
            return null;
        return {
            id: 'androidLaunchIcon',
            title: 'Android Launch Icon',
            value: icon,
            apply: () => setAndroidLaunchIcon(projectPath, mipmaps, icon, roundIcon),
        };
    }
    catch (e) {
        return null;
    }
}
exports.importAndroidLaunchIcon = importAndroidLaunchIcon;
async function setAndroidLaunchIcon(oldProjectPath, mipmaps, icon, roundIcon) {
    const existingMipmaps = await (0, glob_1.glob)(path_1.default.join((0, getProjectPath_1.getProjectPath)(), 'android/app/src/main/res/mipmap-*/*'));
    // delete existing mipmaps
    for (const mipmap of existingMipmaps) {
        await new Promise(r => fs_1.default.unlink(mipmap, r));
    }
    (0, prompter_1.logMessage)('deleted existing mipmaps');
    // copy new mipmaps
    for (const mipmap of mipmaps) {
        // get path after android
        const relativePath = path_1.default.relative(path_1.default.join(oldProjectPath, 'android'), mipmap);
        const destination = path_1.default.join(path_1.default.join((0, getProjectPath_1.getProjectPath)(), 'android'), relativePath);
        // ensure dir exists
        await new Promise(r => fs_1.default.mkdir(path_1.default.dirname(destination), { recursive: true }, r));
        // copy file
        await new Promise(r => fs_1.default.copyFile(mipmap, destination, r));
    }
    (0, prompter_1.logMessage)('copied mipmaps from old project');
    // replace icon and round icon attributes in AndroidManifest.xml
    const manifestPath = path_1.default.join((0, getProjectPath_1.getProjectPath)(), 'android/app/src/main/AndroidManifest.xml');
    const manifest = fs_1.default.readFileSync(manifestPath, 'utf8');
    let newManifest = manifest.replace(/android:icon="(.*)"/, `android:icon="${icon}"`);
    (0, prompter_1.logMessage)(`set ${picocolors_1.default.yellow('android:icon')} to ${picocolors_1.default.yellow(icon)}`);
    if (roundIcon) {
        newManifest = newManifest.replace(/android:roundIcon="(.*)"/, `android:roundIcon="${roundIcon}"`);
        (0, prompter_1.logMessage)(`set ${picocolors_1.default.yellow('android:roundIcon')} to ${picocolors_1.default.yellow(roundIcon)}`);
    }
    else {
        newManifest = newManifest.replace(/\n\s+android:roundIcon="(.*)"/, '');
    }
    fs_1.default.writeFileSync(manifestPath, newManifest);
    return Promise.resolve();
}
