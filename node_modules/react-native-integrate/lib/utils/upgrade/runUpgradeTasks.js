"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runUpgradeTasks = void 0;
const fs_1 = __importDefault(require("fs"));
const glob_1 = require("glob");
const path_1 = __importDefault(require("path"));
const picocolors_1 = __importDefault(require("picocolors"));
const constants_1 = require("../../constants");
const prompter_1 = require("../../prompter");
const variables_1 = require("../../variables");
const getErrMessage_1 = require("../getErrMessage");
const getProjectPath_1 = require("../getProjectPath");
const parseConfig_1 = require("../parseConfig");
const runTask_1 = require("../runTask");
const satisfies_1 = require("../satisfies");
const setState_1 = require("../setState");
const taskManager_1 = require("../taskManager");
async function runUpgradeTasks(oldProjectPath) {
    const configPath = path_1.default.join((0, getProjectPath_1.getProjectPath)(), constants_1.Constants.UPGRADE_FOLDER_NAME, constants_1.Constants.UPGRADE_CONFIG_FILE_NAME);
    if (!fs_1.default.existsSync(configPath)) {
        (0, prompter_1.logMessageGray)('skipped execution, no upgrade.yml found at .upgrade');
        return { didRun: false };
    }
    const packageName = constants_1.Constants.UPGRADE_CONFIG_FILE_NAME;
    let config;
    try {
        config = (0, parseConfig_1.parseConfig)(configPath);
    }
    catch (e) {
        (0, prompter_1.logError)(picocolors_1.default.bold(picocolors_1.default.bgRed(' error ')) +
            picocolors_1.default.bold(picocolors_1.default.blue(` ${packageName} `)) +
            picocolors_1.default.red('could not parse package configuration\n') +
            picocolors_1.default.gray((0, getErrMessage_1.getErrMessage)(e, 'validation')), true);
        return { didRun: false };
    }
    variables_1.variables.clear(); // reset variables
    if (config.env) {
        Object.entries(config.env).forEach(([name, value]) => variables_1.variables.set(name, (0, variables_1.transformTextInObject)(value)));
    }
    let failedTaskCount = 0, completedTaskCount = 0;
    if (config.imports) {
        (0, prompter_1.logInfo)(picocolors_1.default.bold(picocolors_1.default.inverse(picocolors_1.default.cyan(' task '))) +
            picocolors_1.default.bold(picocolors_1.default.cyan(' Import files from old project ')));
        if (oldProjectPath) {
            (0, prompter_1.startSpinner)(`discovering files from ${picocolors_1.default.yellow('old project')}`);
            const filesToCopy = [];
            for (let i = 0; i < config.imports.length; i++) {
                (0, prompter_1.updateSpinner)(`discovering files from ${picocolors_1.default.yellow('old project')} (${i + 1}/${config.imports.length})`);
                const relativePath = (0, variables_1.getText)(config.imports[i]);
                const importPath = path_1.default.join(oldProjectPath, relativePath);
                if (!fs_1.default.existsSync(importPath)) {
                    (0, prompter_1.logWarning)(`skipped import of ${picocolors_1.default.yellow(relativePath)}, path not found in old project`);
                    continue;
                }
                const stat = fs_1.default.lstatSync(importPath);
                if (stat.isDirectory()) {
                    filesToCopy.push(...(await (0, glob_1.glob)(importPath + '/**/*', { nodir: true })));
                }
                else {
                    filesToCopy.push(importPath);
                }
            }
            for (let i = 0; i < filesToCopy.length; i++) {
                (0, prompter_1.updateSpinner)(`copying files from ${picocolors_1.default.yellow('old project')} (${i + 1}/${filesToCopy.length})`);
                const file = filesToCopy[i];
                const relativePath = path_1.default.relative(oldProjectPath, file);
                const destination = path_1.default.join((0, getProjectPath_1.getProjectPath)(), relativePath);
                // ensure dir exists
                await new Promise(r => fs_1.default.mkdir(path_1.default.dirname(destination), { recursive: true }, r));
                await new Promise((res, rej) => {
                    fs_1.default.copyFile(file, destination, err => {
                        if (err)
                            rej(err);
                        else
                            res(null);
                    });
                });
            }
            (0, prompter_1.stopSpinner)(`copied ${picocolors_1.default.yellow(filesToCopy.length)} files`);
            completedTaskCount++;
        }
        else {
            (0, prompter_1.logMessageGray)('skipped importing from old project, no old project path specified');
        }
    }
    if (config.steps) {
        for (const task of config.steps) {
            if (task.when &&
                !(0, satisfies_1.satisfies)(variables_1.variables.getStore(), (0, variables_1.transformTextInObject)(task.when))) {
                (0, setState_1.setState)(task.name, {
                    state: 'skipped',
                    error: false,
                });
                continue;
            }
            (0, setState_1.setState)(task.name, {
                state: 'progress',
                error: false,
            });
            const isNonSystemTask = !taskManager_1.taskManager.isSystemTask(task.task);
            if (isNonSystemTask) {
                if (task.label)
                    task.label = (0, variables_1.getText)(task.label);
                else
                    task.label = taskManager_1.taskManager.task[task.task].summary;
                (0, prompter_1.logInfo)(picocolors_1.default.bold(picocolors_1.default.inverse(picocolors_1.default.cyan(' task '))) +
                    picocolors_1.default.bold(picocolors_1.default.cyan(` ${task.label} `)));
            }
            try {
                await (0, runTask_1.runTask)({
                    configPath,
                    packageName,
                    task,
                });
                completedTaskCount++;
                (0, setState_1.setState)(task.name, {
                    state: 'done',
                    error: false,
                });
            }
            catch (e) {
                failedTaskCount++;
                const errMessage = (0, getErrMessage_1.getErrMessage)(e);
                (0, prompter_1.logError)(errMessage);
                (0, setState_1.setState)(task.name, {
                    state: 'error',
                    reason: errMessage,
                    error: true,
                });
            }
        }
    }
    return { didRun: true, failedTaskCount, completedTaskCount };
}
exports.runUpgradeTasks = runUpgradeTasks;
