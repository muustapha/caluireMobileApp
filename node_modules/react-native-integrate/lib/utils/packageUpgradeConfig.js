"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writePackageUpgradeConfig = exports.addPackageUpgradeInput = exports.addPackageUpgradeFile = exports.getPackageUpgradeConfig = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const prompter_1 = require("../prompter");
const getProjectPath_1 = require("./getProjectPath");
function getPackageUpgradeConfig(packageName) {
    const projectPath = (0, getProjectPath_1.getProjectPath)();
    const upgradePath = path_1.default.join(projectPath, '.upgrade', 'packages', packageName, 'upgrade.json');
    if (!fs_1.default.existsSync(upgradePath)) {
        return {};
    }
    try {
        return JSON.parse(fs_1.default.readFileSync(upgradePath, 'utf8'));
    }
    catch (e) {
        return {};
    }
}
exports.getPackageUpgradeConfig = getPackageUpgradeConfig;
function addPackageUpgradeFile(packageName, file) {
    return writePackageUpgradeConfig(packageName, {
        files: {
            [file]: file,
        },
    });
}
exports.addPackageUpgradeFile = addPackageUpgradeFile;
function addPackageUpgradeInput(packageName, name, value) {
    return writePackageUpgradeConfig(packageName, {
        inputs: {
            [name]: value,
        },
    });
}
exports.addPackageUpgradeInput = addPackageUpgradeInput;
function writePackageUpgradeConfig(packageName, config) {
    const projectPath = (0, getProjectPath_1.getProjectPath)();
    const upgradeJsonPath = path_1.default.join(projectPath, '.upgrade', 'packages', packageName, 'upgrade.json');
    let existingConfig;
    if (!fs_1.default.existsSync(upgradeJsonPath)) {
        existingConfig = {};
    }
    else {
        try {
            existingConfig = JSON.parse(fs_1.default.readFileSync(upgradeJsonPath, 'utf8'));
        }
        catch (e) {
            (0, prompter_1.logWarning)(e?.message);
            existingConfig = {};
        }
    }
    if (config.inputs) {
        existingConfig.inputs = Object.assign(existingConfig.inputs || {}, config.inputs);
    }
    if (config.files) {
        for (const destination of Object.keys(config.files)) {
            const allExistingFiles = Object.values(existingConfig.files || {});
            const fullPath = path_1.default.join((0, getProjectPath_1.getProjectPath)(), destination);
            let fileName = path_1.default.basename(fullPath);
            const extName = path_1.default.extname(fullPath);
            if (allExistingFiles.includes(fileName)) {
                const fileNameWithoutExt = fileName.replace(extName, '');
                const cloneCount = +(/ \(\d+\)$/.exec(fileNameWithoutExt)?.[0] || '1');
                fileName = `${fileNameWithoutExt.replace(/ \(\d+\)$/, '')} (${cloneCount + 1})${extName}`;
            }
            const upgradeFilePath = path_1.default.join(projectPath, '.upgrade', 'packages', packageName, 'files', fileName);
            // copy file
            fs_1.default.mkdirSync(path_1.default.dirname(upgradeFilePath), { recursive: true });
            fs_1.default.copyFileSync(fullPath, upgradeFilePath);
            // set fileName
            config.files[destination] = fileName;
            existingConfig.files = Object.assign(existingConfig.files || {}, config.files);
        }
    }
    fs_1.default.mkdirSync(path_1.default.dirname(upgradeJsonPath), { recursive: true });
    fs_1.default.writeFileSync(upgradeJsonPath, JSON.stringify(existingConfig, null, 2));
}
exports.writePackageUpgradeConfig = writePackageUpgradeConfig;
