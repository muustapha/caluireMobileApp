"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateIntegrationStatus = exports.readLockFile = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("../constants");
const getProjectPath_1 = require("./getProjectPath");
const projectPath = (0, getProjectPath_1.getProjectPath)();
const lockFilePath = path_1.default.join(projectPath, constants_1.Constants.LOCK_FILE_NAME);
function createLockObject() {
    return { lockfileVersion: constants_1.Constants.CURRENT_LOCK_VERSION, packages: {} };
}
function readLockFile() {
    try {
        if (!fs_1.default.existsSync(lockFilePath))
            return {
                lockData: createLockObject(),
                justCreated: true,
            };
        // Read the file and parse it as JSON
        const lockFileContent = fs_1.default.readFileSync(lockFilePath, 'utf-8');
        if (!lockFileContent)
            return {
                lockData: createLockObject(),
                justCreated: true,
            };
        // compare lock version
        const lockData = JSON.parse(lockFileContent);
        if (lockData.lockfileVersion !== constants_1.Constants.CURRENT_LOCK_VERSION) {
            console.error(`Error reading integrate-lock.json: lockfileVersion is not equal to ${constants_1.Constants.CURRENT_LOCK_VERSION}`);
            process.abort();
        }
        return {
            lockData,
            justCreated: false,
        };
    }
    catch (error) {
        console.error('Error reading integrate-lock.json:', error);
        process.abort();
    }
}
exports.readLockFile = readLockFile;
function writeLockFile(data) {
    try {
        fs_1.default.writeFileSync(lockFilePath, JSON.stringify(data, null, 2));
    }
    catch (error) {
        console.error('Error writing integrate-lock.json:', error);
        process.abort();
    }
}
function updateIntegrationStatus(packageIntegrations) {
    const { lockData } = readLockFile();
    if (!lockData.packages)
        lockData.packages = {};
    packageIntegrations.forEach(integration => {
        if (integration.lockProjectData.deleted)
            delete lockData.packages[integration.packageName];
        else
            lockData.packages[integration.packageName] = integration.lockProjectData;
    });
    lockData.packages = Object.keys(lockData.packages)
        .sort()
        .reduce((temp_obj, key) => {
        temp_obj[key] = lockData.packages[key];
        return temp_obj;
    }, {});
    writeLockFile(lockData);
}
exports.updateIntegrationStatus = updateIntegrationStatus;
