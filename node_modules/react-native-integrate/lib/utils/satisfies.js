"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deepEquals = exports.satisfies = void 0;
function satisfies(left, right) {
    if (Array.isArray(right))
        return anySatisfiesArray(left, right);
    else if (typeof right == 'object' && right != null)
        return anySatisfiesObject(left, right);
    return anySatisfiesPrimitive(left, right);
}
exports.satisfies = satisfies;
function anySatisfiesArray(left, right) {
    if (Array.isArray(left))
        return arraySatisfiesArray(left, right);
    //else if (typeof left == 'object') {
    //  this would never match
    //  return objectSatisfiesArray(left, right);
    //}
    // this would never match
    // return primitiveSatisfiesArray(left, right);
    return false;
}
// searches in array
function arraySatisfiesPrimitive(left, right) {
    return left.some((leftChild) => deepEquals(leftChild, right));
}
function arraySatisfiesArray(left, right) {
    return deepEquals(left, right);
}
function arraySatisfiesObject(left, right) {
    let hasOperand = false;
    const result = Object.entries(right).every(([key, value]) => {
        if (key in arrayOperands) {
            hasOperand = true;
            return arrayOperands[key](left, value);
        }
        return false;
    });
    if (hasOperand)
        return result;
    return left.some((leftChild) => deepEquals(leftChild, right));
}
function anySatisfiesObject(left, right) {
    if (Array.isArray(left))
        return arraySatisfiesObject(left, right);
    else if (typeof left == 'object' && left != null)
        return objectSatisfiesObject(left, right);
    return primitiveSatisfiesObject(left, right);
}
function objectSatisfiesObject(left, right) {
    return Object.entries(right).every(([key, value]) => {
        if (key in nonArrayOperands)
            return nonArrayOperands[key](left, value, right);
        return satisfies(left[key], value);
    });
}
function anySatisfiesPrimitive(left, right) {
    if (Array.isArray(left))
        return arraySatisfiesPrimitive(left, right);
    else if (typeof left == 'object' && left != null) {
        // this would never match
        // return objectSatisfiesPrimitive(left, right);
        return false;
    }
    return primitiveSatisfiesPrimitive(left, right);
}
function primitiveSatisfiesPrimitive(left, right) {
    return equals(left, right);
}
function primitiveSatisfiesObject(left, right) {
    return Object.entries(right).every(([key, value]) => {
        if (key in nonArrayOperands)
            return nonArrayOperands[key](left, value, right);
        return false;
    });
}
function equals(left, right) {
    return left == right;
}
function deepEquals(left, right) {
    if (equals(left, right))
        return true;
    if (typeof left != 'object' ||
        typeof right != 'object' ||
        left == null ||
        right == null)
        return false;
    const isLeftArray = Array.isArray(left), isRightArray = Array.isArray(right);
    if (isLeftArray && isRightArray) {
        if (left.length != right.length)
            return false;
        for (let i = 0; i < left.length; i++) {
            if (!deepEquals(left[i], right[i]))
                return false;
        }
        return true;
    }
    if (isLeftArray || isRightArray)
        return false;
    const keysA = Object.keys(left), keysB = Object.keys(right);
    if (keysA.length != keysB.length)
        return false;
    for (const key of keysA) {
        if (!keysB.includes(key))
            return false;
        if (!deepEquals(left[key], right[key]))
            return false;
    }
    return true;
}
exports.deepEquals = deepEquals;
const commonOperands = {
    $and(left, right) {
        if (Array.isArray(right))
            return right.every((rightChild) => satisfies(left, rightChild));
        return satisfies(left, right);
    },
    $or(left, right) {
        if (Array.isArray(right))
            return right.some((rightChild) => satisfies(left, rightChild));
        if (right == undefined)
            return false;
        return Object.entries(right).some(([rightKey, rightChild]) => satisfies(left, { [rightKey]: rightChild }));
    },
    $eq(left, right) {
        return deepEquals(left, right);
    },
    $ne(left, right) {
        return !deepEquals(left, right);
    },
    $not(left, right) {
        return !satisfies(left, right);
    },
};
const arrayOperands = {
    ...commonOperands,
    $elemMatch(left, right) {
        return left.some((leftChild) => satisfies(leftChild, right));
    },
    $all(left, right) {
        if (Array.isArray(right))
            return right.every((rightChild) => left.some((leftChild) => satisfies(leftChild, rightChild)));
        return left.every((leftChild) => satisfies(leftChild, right));
    },
    $any(left, right) {
        if (Array.isArray(right))
            return right.some((rightChild) => left.some((leftChild) => satisfies(leftChild, rightChild)));
        return left.some((leftChild) => satisfies(leftChild, right));
    },
    $size(left, right) {
        return satisfies(left.length, right);
    },
};
const nonArrayOperands = {
    ...commonOperands,
    $gt(left, right) {
        if (left == undefined || right == undefined)
            return false;
        return left > right;
    },
    $gte(left, right) {
        if (left == undefined || right == undefined)
            return false;
        return left >= right;
    },
    $lt(left, right) {
        if (left == undefined || right == undefined)
            return false;
        return left < right;
    },
    $lte(left, right) {
        if (left == undefined || right == undefined)
            return false;
        return left <= right;
    },
    $in(left, right) {
        if (Array.isArray(right))
            return right.includes(left);
        return false;
    },
    $nin(left, right) {
        if (Array.isArray(right))
            return !right.includes(left);
        return true;
    },
    $exists(left, right) {
        return right ? left != undefined : left == undefined;
    },
    $regex(left, right, operandParent) {
        if (typeof right != 'string' || typeof left != 'string')
            return false;
        let options = operandParent.$options;
        if (typeof options != 'string')
            options = undefined;
        return new RegExp(right, options).test(left);
    },
    $options() {
        return true;
    },
};
