"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getModContent = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("../constants");
const variables_1 = require("../variables");
const getPackageConfig_1 = require("./getPackageConfig");
async function getModContent(configPath, packageName, textOrFile) {
    if (typeof textOrFile == 'string')
        return (0, variables_1.getText)(textOrFile);
    const fullFilePath = path_1.default.join(configPath, '..', textOrFile.file);
    if (!fs_1.default.existsSync(fullFilePath) &&
        packageName !== constants_1.Constants.UPGRADE_CONFIG_FILE_NAME) {
        const remotePath = (0, getPackageConfig_1.getRemotePath)(packageName, constants_1.Constants.REMOTE_REPO) +
            fullFilePath.replace(path_1.default.join(configPath, '../'), '');
        const localDir = path_1.default.join(fullFilePath, '..');
        if (!fs_1.default.existsSync(localDir))
            fs_1.default.mkdirSync(localDir, { recursive: true });
        const success = await (0, getPackageConfig_1.downloadFile)(remotePath, fullFilePath);
        if (!success)
            throw new Error(`File not found at ${fullFilePath}`);
    }
    return (0, variables_1.getText)(fs_1.default.readFileSync(fullFilePath, 'utf-8'));
}
exports.getModContent = getModContent;
