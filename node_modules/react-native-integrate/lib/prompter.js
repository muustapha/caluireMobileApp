"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.summarize = exports.text = exports.confirm = exports.select = exports.multiselect = exports.stopSpinner = exports.updateSpinner = exports.startSpinner = exports.logOutro = exports.logIntro = exports.logNote = exports.logError = exports.logInfo = exports.logWarning = exports.logMessageGray = exports.logMessage = exports.logSuccess = exports.log = void 0;
const prompts_1 = require("@clack/prompts");
const picocolors_1 = __importDefault(require("picocolors"));
const waitInputToContinue_1 = require("./utils/waitInputToContinue");
function log(msg) {
    prompts_1.log.step(msg);
}
exports.log = log;
function logSuccess(msg) {
    prompts_1.log.success(msg);
}
exports.logSuccess = logSuccess;
function logMessage(msg) {
    prompts_1.log.message('⦿ ' + msg);
}
exports.logMessage = logMessage;
function logMessageGray(msg) {
    prompts_1.log.message(picocolors_1.default.gray('⦿ ' + msg));
}
exports.logMessageGray = logMessageGray;
function logWarning(msg, noColor) {
    prompts_1.log.warning(noColor ? msg : picocolors_1.default.yellow(msg));
}
exports.logWarning = logWarning;
function logInfo(msg) {
    prompts_1.log.info(msg);
}
exports.logInfo = logInfo;
function logError(msg, noColor) {
    prompts_1.log.error(noColor ? msg : picocolors_1.default.red(msg));
}
exports.logError = logError;
function logNote(msg, title) {
    (0, prompts_1.note)(msg, title);
}
exports.logNote = logNote;
function logIntro(msg) {
    (0, prompts_1.intro)(picocolors_1.default.inverse(` ${msg || 'react-native-integrate'} `));
}
exports.logIntro = logIntro;
function logOutro(msg) {
    (0, prompts_1.outro)(picocolors_1.default.cyan(msg || 'completed integration check'));
}
exports.logOutro = logOutro;
const s = (0, prompts_1.spinner)();
let releaseListener;
function startSpinner(msg, onCancel) {
    s.start(msg);
    if (onCancel)
        releaseListener = (0, waitInputToContinue_1.listenForKeys)('s', onCancel);
}
exports.startSpinner = startSpinner;
function updateSpinner(msg) {
    s.message(msg);
}
exports.updateSpinner = updateSpinner;
function stopSpinner(msg) {
    s.stop(msg);
    if (releaseListener) {
        releaseListener();
        releaseListener = undefined;
    }
}
exports.stopSpinner = stopSpinner;
async function multiselect(msg, args) {
    const response = await (0, prompts_1.multiselect)({
        message: msg,
        required: args.required,
        options: args.options.map(x => ({
            value: x.value,
            label: x.label || x.value.toString(),
            hint: x.hint,
        })),
        initialValues: args.initialValues,
    });
    if ((0, prompts_1.isCancel)(response)) {
        (0, prompts_1.cancel)('operation cancelled');
        process.abort();
    }
    // @ts-ignore
    return response;
}
exports.multiselect = multiselect;
async function select(msg, args) {
    const response = await (0, prompts_1.select)({
        message: msg,
        options: args.options.map(x => ({
            value: x.value,
            label: x.label || x.value.toString(),
            hint: x.hint,
        })),
        initialValue: args.initialValue,
        maxItems: args.maxItems,
    });
    if ((0, prompts_1.isCancel)(response)) {
        (0, prompts_1.cancel)('operation cancelled');
        process.abort();
    }
    // @ts-ignore
    return response;
}
exports.select = select;
async function confirm(msg, args = {}) {
    const response = await (0, prompts_1.confirm)({
        message: msg,
        active: args.positive || 'yes',
        inactive: args.negative || 'no',
        initialValue: args.initialValue,
    });
    if ((0, prompts_1.isCancel)(response)) {
        (0, prompts_1.cancel)('operation cancelled');
        process.abort();
    }
    return response;
}
exports.confirm = confirm;
async function text(msg, args = {}) {
    const response = await (0, prompts_1.text)({
        message: msg,
        defaultValue: args.defaultValue,
        initialValue: args.initialValue,
        placeholder: args.placeholder,
        validate: args.validate,
    });
    if ((0, prompts_1.isCancel)(response)) {
        (0, prompts_1.cancel)('operation cancelled');
        process.abort();
    }
    return response;
}
exports.text = text;
function summarize(code, maxLength = 128) {
    if (code == null)
        return 'null';
    const flatText = code.replace(/\n/g, '⏎');
    return picocolors_1.default.yellow(flatText.substring(0, maxLength) +
        (flatText.length > maxLength ? '...' : ''));
}
exports.summarize = summarize;
